/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/avo/action-mode/action-mode.js":
/*!********************************************!*\
  !*** ./src/avo/action-mode/action-mode.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/misc/constants */ \"./src/avo/misc/constants.js\");\n/* harmony import */ var _avo_misc_physics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/misc/physics */ \"./src/avo/misc/physics.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\nvar ActionMode =\n/*#__PURE__*/\nfunction () {\n  function ActionMode(app) {\n    _classCallCheck(this, ActionMode);\n\n    this._app = app;\n    this.html = document.getElementById('action-mode');\n    this.width = 320;\n    this.height = 240;\n    this.canvas2d = this.html.getContext(\"2d\"); // Set HTML\n\n    this.html.width = this.width;\n    this.html.height = this.height;\n    this.canvasSizeRatio = 1;\n    this.html.onkeydown = this.onKeyDown.bind(this);\n    this.html.onkeyup = this.onKeyUp.bind(this); // Keys that are currently being pressed, and the number of frames they've\n    // been pressed for.\n\n    this.keysPressed = {};\n  }\n\n  _createClass(ActionMode, [{\n    key: \"load\",\n    value: function load() {\n      this.focus();\n    }\n  }, {\n    key: \"unload\",\n    value: function unload() {}\n  }, {\n    key: \"focus\",\n    value: function focus() {\n      this.html.focus();\n    }\n  }, {\n    key: \"play\",\n    value: function play() {\n      var _this = this;\n\n      var app = this._app;\n      this.processPlayerInput(); // Sort for visual rendering\n      // TODO: check if this is necessary.\n\n      function sortY(a, b) {\n        return a.y - b.y;\n      }\n\n      app.actors.sort(sortY);\n      app.particles.sort(sortY); // Run logic for each Story Element\n\n      app.actors.forEach(function (actor) {\n        actor.play();\n      });\n      app.particles.forEach(function (particle) {\n        particle.play();\n      });\n      this.processPhysics(); // Increment the duration of each currently pressed key\n\n      Object.keys(this.keysPressed).forEach(function (key) {\n        if (_this.keysPressed[key]) _this.keysPressed[key]++;\n      }); // Camera Controls: focus the camera on the target actor, if any.\n\n      if (app.camera.targetActor) {\n        app.camera.x = this.width / 2 - app.camera.targetActor.x;\n        app.camera.y = this.height / 2 - app.camera.targetActor.y;\n      }\n    }\n  }, {\n    key: \"paint\",\n    value: function paint() {\n      // TODO: see https://www.html5rocks.com/en/tutorials/canvas/hidpi/ about using window.devicePixelRatio to fix blurriness on a High DPI canvas\n      var app = this._app;\n      var canvas2d = this.canvas2d;\n      var camera = app.camera; // Clear canvas before painting\n\n      canvas2d.clearRect(0, 0, this.width, this.height); // Paint the map (floor)\n\n      app.map && app.map.paint(canvas2d, camera, {}); // Paint each Story Element\n\n      app.particles.forEach(function (particle) {\n        particle.paint(canvas2d, camera, {});\n      });\n      app.actors.forEach(function (actor) {\n        actor.paint(canvas2d, camera, {});\n      });\n    }\n  }, {\n    key: \"focus\",\n    value: function focus() {\n      this.html.focus();\n    }\n  }, {\n    key: \"onKeyDown\",\n    value: function onKeyDown(e) {\n      if (!this.keysPressed[e.key]) this.keysPressed[e.key] = 1;\n    }\n  }, {\n    key: \"onKeyUp\",\n    value: function onKeyUp(e) {\n      this.keysPressed[e.key] = undefined;\n    }\n  }, {\n    key: \"processPlayerInput\",\n    value: function processPlayerInput() {\n      var app = this._app;\n      var playerActor = app.playerActor;\n\n      if (playerActor) {\n        playerActor.intent = undefined;\n        var moveX = 0;\n        var moveY = 0;\n        if (this.keysPressed['ArrowRight']) moveX++;\n        if (this.keysPressed['ArrowDown']) moveY++;\n        if (this.keysPressed['ArrowLeft']) moveX--;\n        if (this.keysPressed['ArrowUp']) moveY--;\n\n        if (this.keysPressed[' '] === _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"SHORT_KEYPRESS_DURATION\"]) {\n          playerActor.intent = {\n            name: 'attack'\n          };\n        } else if (moveX || moveY) {\n          playerActor.intent = {\n            name: 'move',\n            attr: {\n              x: moveX,\n              y: moveY\n            }\n          };\n        }\n      }\n    }\n  }, {\n    key: \"processPhysics\",\n    value: function processPhysics() {\n      var app = this._app; // Move Actors and Particles\n\n      app.actors.forEach(function (actor) {\n        actor.x += actor.moveX;\n        actor.y += actor.moveY;\n        actor.x += actor.pushX;\n        actor.y += actor.pushY;\n        actor.pushX = 0;\n        actor.pushY = 0;\n      });\n      app.particles.forEach(function (particle) {\n        particle.x += particle.moveX;\n        particle.y += particle.moveY;\n        particle.x += particle.pushX;\n        particle.y += particle.pushY;\n        particle.pushX = 0;\n        particle.pushY = 0;\n      }); // Check Map tiles\n\n      var map = app.map;\n      app.actors.forEach(function (actor) {\n        var collisionCorrection = map.checkCollision(actor);\n\n        if (collisionCorrection) {\n          actor.x = collisionCorrection.x;\n          actor.y = collisionCorrection.y;\n        }\n      }); // Check Actor collisions\n\n      for (var a = 0; a < app.actors.length; a++) {\n        var actorA = app.actors[a]; // ...with other Actors\n\n        for (var b = a + 1; b < app.actors.length; b++) {\n          var actorB = app.actors[b];\n          var collisionCorrection = _avo_misc_physics__WEBPACK_IMPORTED_MODULE_1__[\"Physics\"].checkCollision(actorA, actorB);\n\n          if (collisionCorrection) {\n            actorA.x = collisionCorrection.ax;\n            actorA.y = collisionCorrection.ay;\n            actorB.x = collisionCorrection.bx;\n            actorB.y = collisionCorrection.by;\n            actorA.onCollision(actorB, collisionCorrection);\n            actorB.onCollision(actorA, collisionCorrection);\n          }\n        }\n      } // Check Particle collisions\n\n\n      for (var _a = 0; _a < app.particles.length; _a++) {\n        var particleA = app.particles[_a]; // ...with other Particles\n\n        for (var _b = _a + 1; _b < app.particles.length; _b++) {\n          var particleB = app.particles[_b];\n\n          var _collisionCorrection = _avo_misc_physics__WEBPACK_IMPORTED_MODULE_1__[\"Physics\"].checkCollision(particleA, particleB);\n\n          if (_collisionCorrection) {\n            particleA.onCollision(particleB, _collisionCorrection);\n            particleB.onCollision(particleA, _collisionCorrection);\n          }\n        } // ...with Actors\n\n\n        for (var _b2 = 0; _b2 < app.actors.length; _b2++) {\n          var _actorB = app.actors[_b2];\n\n          var _collisionCorrection2 = _avo_misc_physics__WEBPACK_IMPORTED_MODULE_1__[\"Physics\"].checkCollision(particleA, _actorB);\n\n          if (_collisionCorrection2) {\n            particleA.onCollision(_actorB, _collisionCorrection2);\n\n            _actorB.onCollision(particleA, _collisionCorrection2);\n          }\n        }\n      }\n    }\n  }]);\n\n  return ActionMode;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (ActionMode);\n\n//# sourceURL=webpack:///./src/avo/action-mode/action-mode.js?");

/***/ }),

/***/ "./src/avo/action-mode/index.js":
/*!**************************************!*\
  !*** ./src/avo/action-mode/index.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _action_mode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./action-mode */ \"./src/avo/action-mode/action-mode.js\");\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (_action_mode__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack:///./src/avo/action-mode/index.js?");

/***/ }),

/***/ "./src/avo/actions/index.js":
/*!**********************************!*\
  !*** ./src/avo/actions/index.js ***!
  \**********************************/
/*! exports provided: STANDARD_ACTIONS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"STANDARD_ACTIONS\", function() { return STANDARD_ACTIONS; });\n/* harmony import */ var _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/misc/constants */ \"./src/avo/misc/constants.js\");\n/* harmony import */ var _avo_animations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/animations */ \"./src/avo/animations/index.js\");\n/* harmony import */ var _avo_story_elements_particle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @avo/story-elements/particle */ \"./src/avo/story-elements/particle.js\");\n\n\n\nvar STANDARD_ACTIONS = {\n  IDLE: {\n    type: _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION_TYPES\"].IDLE,\n    steps: 1,\n    script: function script(app, actor, action, actionAttr, step) {\n      actor.animationName = 'idle';\n    }\n  },\n  MOVE: {\n    type: _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION_TYPES\"].CONTINUOUS,\n    steps: 6 * 2,\n    script: function script(app, actor, action, actionAttr, step) {\n      var acceleration = actor.stats.acceleration || 0;\n      var actionRotation = Math.atan2(actionAttr.y, actionAttr.x);\n      var moveX = actor.moveX + acceleration * Math.cos(actionRotation);\n      var moveY = actor.moveY + acceleration * Math.sin(actionRotation);\n\n      if (actor.stats.maxSpeed >= 0) {\n        var maxSpeed = actor.stats.maxSpeed;\n        var correctedSpeed = Math.min(maxSpeed, Math.sqrt(moveX * moveX + moveY * moveY));\n        var moveRotation = Math.atan2(moveY, moveX);\n        moveX = correctedSpeed * Math.cos(moveRotation);\n        moveY = correctedSpeed * Math.sin(moveRotation);\n      }\n\n      actor.moveX = moveX;\n      actor.moveY = moveY;\n      actor.rotation = actionRotation;\n      if (0 * 2 <= step && step < 1 * 2) actor.animationName = 'move-1';else if (1 * 2 <= step && step < 3 * 2) actor.animationName = 'move-2';else if (3 * 2 <= step && step < 4 * 2) actor.animationName = 'move-1';else if (4 * 2 <= step && step < 6 * 2) actor.animationName = 'move-3';\n    }\n  },\n  ATTACK: {\n    type: _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION_TYPES\"].STANDARD,\n    steps: 15,\n    script: function script(app, actor, action, actionAttr, step) {\n      if (step < 10) {\n        actor.animationName = 'attack-windup';\n      } else if (step === 10) {\n        var particle = new _avo_story_elements_particle__WEBPACK_IMPORTED_MODULE_2__[\"default\"](app, {\n          x: actor.x + Math.cos(actor.rotation) * actor.size * 0.8,\n          y: actor.y + Math.sin(actor.rotation) * actor.size * 0.8,\n          size: actor.size * 1,\n          duration: 5,\n          source: actor,\n          ignoreSource: true,\n          stats: {\n            attackPower: 20,\n            pushPower: 8,\n            pushAngle: actor.rotation,\n            pushDuration: 6,\n            pushDecay: 1\n          },\n          scripts: {\n            'collision': function collision(app, particle, target) {\n              if (target && target.stats) {\n                target.stats.health = Math.max((target.stats.health || 0) - particle.stats.attackPower, 0);\n                particle.applyEffect({\n                  name: 'push',\n                  attr: {\n                    power: particle.stats.pushPower,\n                    angle: particle.stats.pushAngle,\n                    decay: particle.stats.pushDecay\n                  },\n                  duration: particle.stats.pushDuration,\n                  stacking: _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"EFFECTS_STACKING\"].STACK\n                }, target);\n              }\n            }\n          },\n          animationScript: _avo_animations__WEBPACK_IMPORTED_MODULE_1__[\"STANDARD_ANIMATIONS\"].PARTICLE\n        });\n        app.particles.push(particle);\n        actor.animationName = 'attack-active';\n      } else {\n        actor.animationName = 'attack-winddown';\n      }\n    }\n  }\n};\n\n//# sourceURL=webpack:///./src/avo/actions/index.js?");

/***/ }),

/***/ "./src/avo/animations/index.js":
/*!*************************************!*\
  !*** ./src/avo/animations/index.js ***!
  \*************************************/
/*! exports provided: STANDARD_ANIMATIONS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"STANDARD_ANIMATIONS\", function() { return STANDARD_ANIMATIONS; });\n/* harmony import */ var _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/misc/constants */ \"./src/avo/misc/constants.js\");\n\nvar STANDARD_ANIMATIONS = {\n  ACTOR: function ACTOR(app, element, canvas, camera) {\n    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    var layer = options.layer || '';\n    if (!canvas || !camera) return; // Simple shadow\n\n    canvas.fillStyle = 'rgba(0, 0, 0, 0.5)'; // --------\n    // Temporary 'animation'\n\n    if (element.animationName === 'idle') canvas.fillStyle = 'rgba(0, 0, 0, 0.5)';else if (element.animationName === 'move-1') canvas.fillStyle = 'rgba(0, 128, 128, 0.5)';else if (element.animationName === 'move-2') canvas.fillStyle = 'rgba(0, 160, 128, 0.5)';else if (element.animationName === 'move-3') canvas.fillStyle = 'rgba(0, 128, 160, 0.5)';else if (element.animationName === 'attack-windup') canvas.fillStyle = 'rgba(192, 192, 0, 0.5)';else if (element.animationName === 'attack-active') canvas.fillStyle = 'rgba(255, 0, 0, 0.5)';else if (element.animationName === 'attack-winddown') canvas.fillStyle = 'rgba(192, 128, 0, 0.5)'; // --------\n\n    canvas.beginPath();\n    canvas.arc(Math.floor(element.x + camera.x), Math.floor(element.y + camera.y), element.size / 2, 0, 2 * Math.PI);\n    canvas.fill(); // Simple direction\n    // --------\n\n    canvas.strokeStyle = 'rgba(0, 0, 0, 0.5)';\n    canvas.lineWidth = 2;\n    canvas.beginPath();\n    canvas.moveTo(Math.floor(element.x + camera.x), Math.floor(element.y + camera.y));\n    canvas.lineTo(Math.floor(element.x + camera.x) + Math.cos(element.rotation) * element.size * 0.6, Math.floor(element.y + camera.y) + Math.sin(element.rotation) * element.size * 0.6);\n    canvas.stroke(); // --------\n    // Paint actor sprite\n    // --------\n\n    if (element.animationSpritesheet) {\n      var SPRITE_SIZE = 48;\n      var SPRITE_OFFSET_X = 0;\n      var SPRITE_OFFSET_Y = -8;\n      var srcSizeX = SPRITE_SIZE;\n      var srcSizeY = SPRITE_SIZE;\n      var srcX = 0;\n      var srcY = 0;\n\n      switch (element.direction) {\n        case _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"DIRECTIONS\"].SOUTH:\n          srcX = SPRITE_SIZE * 0;\n          break;\n\n        case _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"DIRECTIONS\"].NORTH:\n          srcX = SPRITE_SIZE * 1;\n          break;\n\n        case _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"DIRECTIONS\"].EAST:\n          srcX = SPRITE_SIZE * 2;\n          break;\n\n        case _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"DIRECTIONS\"].WEST:\n          srcX = SPRITE_SIZE * 3;\n          break;\n      }\n\n      switch (element.animationName) {\n        case 'move-1':\n          srcY = SPRITE_SIZE * 1;\n          break;\n\n        case 'move-2':\n          srcY = SPRITE_SIZE * 2;\n          break;\n\n        case 'move-3':\n          srcY = SPRITE_SIZE * 3;\n          break;\n\n        case 'attack-windup':\n          srcY = SPRITE_SIZE * 4;\n          break;\n\n        case 'attack-active':\n          srcY = SPRITE_SIZE * 5;\n          break;\n\n        case 'attack-winddown':\n          srcY = SPRITE_SIZE * 5;\n          break;\n      }\n\n      var tgtSizeX = SPRITE_SIZE;\n      var tgtSizeY = SPRITE_SIZE;\n      var tgtX = Math.floor(element.x + camera.x) - srcSizeX / 2 + SPRITE_OFFSET_X;\n      var tgtY = Math.floor(element.y + camera.y) - srcSizeY / 2 + SPRITE_OFFSET_Y;\n      canvas.drawImage(element.animationSpritesheet.img, srcX, srcY, srcSizeX, srcSizeY, tgtX, tgtY, tgtSizeX, tgtSizeY);\n    } // --------\n    // Paint UI elements\n    // --------\n\n\n    var healthOffsetY = 7;\n    var healthRatio = element.stats.maxHealth > 0 ? (element.stats.health || 0) / element.stats.maxHealth : 0;\n    canvas.strokeStyle = 'rgba(0, 0, 0)';\n    canvas.lineWidth = 4;\n    canvas.beginPath();\n    canvas.moveTo(Math.floor(element.x + camera.x) - element.size / 3, Math.floor(element.y + camera.y) + element.size / 2 + healthOffsetY);\n    canvas.lineTo(Math.floor(element.x + camera.x) + element.size / 3, Math.floor(element.y + camera.y) + element.size / 2 + healthOffsetY);\n    canvas.stroke();\n    canvas.strokeStyle = 'rgba(255, 0, 0)';\n    canvas.lineWidth = 2;\n    canvas.beginPath();\n    canvas.moveTo(Math.floor(element.x + camera.x) - element.size / 3 * healthRatio, Math.floor(element.y + camera.y) + element.size / 2 + healthOffsetY);\n    canvas.lineTo(Math.floor(element.x + camera.x) + element.size / 3 * healthRatio, Math.floor(element.y + camera.y) + element.size / 2 + healthOffsetY);\n    canvas.stroke();\n    healthOffsetY = 4;\n    canvas.font = '8px Arial';\n    canvas.fillStyle = 'rgba(204, 68, 68)';\n    canvas.textBaseline = 'hanging';\n    canvas.textAlign = 'right';\n    canvas.fillText('❤️', Math.floor(element.x + camera.x) - element.size / 3, Math.floor(element.y + camera.y) + element.size / 2 + healthOffsetY);\n    canvas.textAlign = 'left';\n    canvas.fillText(Math.floor(element.stats.health), Math.floor(element.x + camera.x) + element.size / 3, Math.floor(element.y + camera.y) + element.size / 2 + healthOffsetY); // --------\n  },\n  PARTICLE: function PARTICLE(app, element, canvas, camera) {\n    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    var layer = options.layer || '';\n    if (!canvas || !camera) return; // Simple shadow\n\n    canvas.fillStyle = 'rgba(238, 238, 204, 0.5)';\n    canvas.beginPath();\n    canvas.arc(element.x + camera.x, element.y + camera.y, element.size / 2, 0, 2 * Math.PI);\n    canvas.fill();\n  }\n};\n\n//# sourceURL=webpack:///./src/avo/animations/index.js?");

/***/ }),

/***/ "./src/avo/avo-adventure.js":
/*!**********************************!*\
  !*** ./src/avo/avo-adventure.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _avo_action_mode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/action-mode */ \"./src/avo/action-mode/index.js\");\n/* harmony import */ var _avo_story__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/story */ \"./src/avo/story.js\");\n/* harmony import */ var _avo_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @avo/map */ \"./src/avo/map/index.js\");\n/* harmony import */ var _avo_misc_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @avo/misc/constants */ \"./src/avo/misc/constants.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n\nvar AvoAdventure =\n/*#__PURE__*/\nfunction () {\n  function AvoAdventure(story) {\n    _classCallCheck(this, AvoAdventure);\n\n    this.mode = _avo_misc_constants__WEBPACK_IMPORTED_MODULE_3__[\"MODES\"].INITIALISING;\n    this.actors = [];\n    this.particles = [];\n    this.assets = {};\n    this.data = {};\n    this.map = new _avo_map__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this);\n    this.camera = {\n      x: 0,\n      y: 0,\n      targetActor: null // Sets an Actor to follow. If null, camera is static.\n\n    };\n    this.playerActor = null;\n    this.actionMode = new _avo_action_mode__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this); // Initialise the story\n\n    this.story = story || new _avo_story__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this);\n    this.nextFrame = null;\n    this.main();\n  }\n\n  _createClass(AvoAdventure, [{\n    key: \"changeMode\",\n    value: function changeMode(newMode) {\n      if (this.mode === _avo_misc_constants__WEBPACK_IMPORTED_MODULE_3__[\"MODES\"].ACTION) this.actionMode.unload(this);\n      if (newMode === _avo_misc_constants__WEBPACK_IMPORTED_MODULE_3__[\"MODES\"].ACTION) this.actionMode.load(this);\n      this.mode = newMode;\n    }\n    /*  Each main step is a 'frame' in the game\r\n     */\n\n  }, {\n    key: \"main\",\n    value: function main() {\n      if (this.mode === _avo_misc_constants__WEBPACK_IMPORTED_MODULE_3__[\"MODES\"].INITIALISING) this.startStoryIfReady(); // Run game logic and update game visuals\n      // Note: gameplay and visual frames are tied.\n\n      this.play();\n      this.paint();\n      this.cleanUp();\n      this.nextFrame = setTimeout(this.main.bind(this), 1000 / _avo_misc_constants__WEBPACK_IMPORTED_MODULE_3__[\"FRAMES_PER_SECOND\"]);\n    }\n    /*  Run game logic\r\n     */\n\n  }, {\n    key: \"play\",\n    value: function play() {\n      var story = this.story;\n\n      if (!story.skipPlay()) {\n        if (this.mode === _avo_misc_constants__WEBPACK_IMPORTED_MODULE_3__[\"MODES\"].ACTION) this.actionMode.play(this);\n      }\n\n      story.customPlay(this);\n    }\n    /*  Update game visuals\r\n     */\n\n  }, {\n    key: \"paint\",\n    value: function paint() {\n      var story = this.story;\n\n      if (!story.skipPaint()) {\n        if (this.mode === _avo_misc_constants__WEBPACK_IMPORTED_MODULE_3__[\"MODES\"].ACTION) this.actionMode.paint(this);\n      }\n\n      story.customPaint(this);\n    }\n    /*  Remove expired elements\r\n     */\n\n  }, {\n    key: \"cleanUp\",\n    value: function cleanUp() {\n      this.actors = this.actors.filter(function (actor) {\n        return !actor._expired;\n      });\n      this.particles = this.particles.filter(function (particle) {\n        return !particle._expired;\n      });\n    }\n    /*  Check if Story is ready to start\r\n     */\n\n  }, {\n    key: \"startStoryIfReady\",\n    value: function startStoryIfReady() {\n      var _this = this;\n\n      if (this.mode !== _avo_misc_constants__WEBPACK_IMPORTED_MODULE_3__[\"MODES\"].INITIALISING) return; // Assets Check\n\n      var allAssetsLoaded = true;\n      Object.keys(this.assets).forEach(function (id) {\n        var asset = _this.assets[id];\n        allAssetsLoaded = allAssetsLoaded && asset.loaded;\n      });\n\n      if (allAssetsLoaded) {\n        this.story.start(this);\n      }\n    }\n  }]);\n\n  return AvoAdventure;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (AvoAdventure);\n\n//# sourceURL=webpack:///./src/avo/avo-adventure.js?");

/***/ }),

/***/ "./src/avo/index.js":
/*!**************************!*\
  !*** ./src/avo/index.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _avo_adventure__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./avo-adventure */ \"./src/avo/avo-adventure.js\");\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (_avo_adventure__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack:///./src/avo/index.js?");

/***/ }),

/***/ "./src/avo/map/index.js":
/*!******************************!*\
  !*** ./src/avo/map/index.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map */ \"./src/avo/map/map.js\");\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (_map__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack:///./src/avo/map/index.js?");

/***/ }),

/***/ "./src/avo/map/map.js":
/*!****************************!*\
  !*** ./src/avo/map/map.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar DEFAULT_TILE_TYPE = {\n  floor: false,\n  wall: false,\n  colour: '#fff'\n};\n\nvar Map =\n/*#__PURE__*/\nfunction () {\n  function Map(app, initialValues) {\n    _classCallCheck(this, Map);\n\n    this._app = app;\n    this.width = 16;\n    this.height = 16;\n    this.tiles = '# ############  ' + '  #          ## ' + '##            ##' + '#              #' + '#    ##  ###   #' + '#   ##     #   #' + '#   #      #   #' + '#      ##      #' + '#      ##      #' + '#   #      #   #' + '#   #      #   #' + '#   ###  ###   #' + '#              #' + '##    ####    ##' + ' ##          ## ' + '  ############  ';\n    this.tileSize = 32;\n    this.tileTypes = {\n      ' ': {\n        floor: true,\n        wall: false,\n        colour: '#eec'\n      },\n      '#': {\n        floor: true,\n        wall: true,\n        colour: '#844'\n      }\n    }; // Set initial values\n\n    Object.assign(this, initialValues);\n  }\n\n  _createClass(Map, [{\n    key: \"paint\",\n    value: function paint(canvas, camera) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var app = this._app;\n      var size = this.tileSize;\n      if (!canvas || !camera) return;\n\n      for (var row = 0; row < this.height; row++) {\n        for (var col = 0; col < this.height; col++) {\n          var tile = this.getTile(col, row);\n          canvas.fillStyle = tile && tile.colour || '#fff';\n          canvas.fillRect(Math.floor(col * size + camera.x), Math.floor(row * size + camera.y), size, size);\n        }\n      }\n    }\n  }, {\n    key: \"checkCollision\",\n    value: function checkCollision(element) {\n      if (!element || !element.solid) return;\n      var size = this.tileSize;\n      var leftCol = Math.floor(element.left / size);\n      var midCol = Math.floor(element.x / size);\n      var rightCol = Math.floor(element.right / size);\n      var topRow = Math.floor(element.top / size);\n      var midRow = Math.floor(element.y / size);\n      var bottomRow = Math.floor(element.bottom / size);\n      var tileL = this.getTile(leftCol, midRow);\n      var tileR = this.getTile(rightCol, midRow);\n      var tileT = this.getTile(midCol, topRow);\n      var tileB = this.getTile(midCol, bottomRow);\n      var tileLT = this.getTile(leftCol, topRow);\n      var tileRT = this.getTile(rightCol, topRow);\n      var tileLB = this.getTile(leftCol, bottomRow);\n      var tileRB = this.getTile(rightCol, bottomRow); // Determine which tiles are blocking the element, and in which direction\n      // the correction needs to be done.\n\n      var correctionDirectionX = 0;\n      var correctionDirectionY = 0;\n\n      if (tileL.wall) {\n        correctionDirectionX++;\n      }\n\n      if (tileR.wall) {\n        correctionDirectionX--;\n      }\n\n      if (tileT.wall) {\n        correctionDirectionY++;\n      }\n\n      if (tileB.wall) {\n        correctionDirectionY--;\n      }\n      /*\r\n      if (tileLT.wall) { correctionDirectionX++; correctionDirectionY++; }\r\n      if (tileRT.wall) { correctionDirectionX--; correctionDirectionY++; }\r\n      if (tileLB.wall) { correctionDirectionX++; correctionDirectionY--; }\r\n      if (tileRB.wall) { correctionDirectionX--; correctionDirectionY--; }\r\n      */\n\n\n      var correctionX = 0;\n      var correctionY = 0;\n      var penetratingX = 0;\n      var penetratingY = 0; // Determine how far the correction needs to be made.\n      // (i.e. determine how 'deep' the element pushed into the blocking tile.)\n\n      if (correctionDirectionX > 0) {\n        var tileEdgeX = leftCol * size + size;\n        penetratingX = element.left - tileEdgeX;\n        correctionX = Math.min(-penetratingX, 2);\n      } else if (correctionDirectionX < 0) {\n        var _tileEdgeX = rightCol * size;\n\n        penetratingX = element.right - _tileEdgeX;\n        correctionX = Math.max(-penetratingX, -2);\n      }\n\n      if (correctionDirectionY > 0) {\n        var tileEdgeY = topRow * size + size;\n        penetratingY = element.top - tileEdgeY;\n        correctionY = Math.min(-penetratingY, 2);\n      } else if (correctionDirectionY < 0) {\n        var _tileEdgeY = bottomRow * size;\n\n        penetratingY = element.bottom - _tileEdgeY;\n        correctionY = Math.max(-penetratingY, -2);\n      }\n\n      var collisionCorrectedX = element.x + correctionX;\n      var collisionCorrectedY = element.y + correctionY; // DEBUG\n\n      if (element === this._app.playerActor) console.log('penX: ', penetratingX.toFixed(2), ' / penY: ', penetratingY.toFixed(2));\n      return {\n        x: collisionCorrectedX,\n        y: collisionCorrectedY\n      };\n    }\n  }, {\n    key: \"getTile\",\n    value: function getTile(col, row) {\n      var index = col >= 0 && col < this.width && row >= 0 && row < this.height ? row * this.width + col : undefined;\n      var size = this.tileSize;\n      var tileValue = this.tiles[index] || '';\n      var tileType = this.tileTypes[tileValue] || DEFAULT_TILE_TYPE;\n      return _objectSpread({\n        col: col,\n        row: row\n      }, tileType);\n    }\n  }]);\n\n  return Map;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Map);\n\n//# sourceURL=webpack:///./src/avo/map/map.js?");

/***/ }),

/***/ "./src/avo/misc/constants.js":
/*!***********************************!*\
  !*** ./src/avo/misc/constants.js ***!
  \***********************************/
/*! exports provided: FRAMES_PER_SECOND, SHORT_KEYPRESS_DURATION, MODES, SHAPES, ROTATIONS, DIRECTIONS, ACTION_TYPES, EFFECTS_STACKING */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FRAMES_PER_SECOND\", function() { return FRAMES_PER_SECOND; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SHORT_KEYPRESS_DURATION\", function() { return SHORT_KEYPRESS_DURATION; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MODES\", function() { return MODES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SHAPES\", function() { return SHAPES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ROTATIONS\", function() { return ROTATIONS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DIRECTIONS\", function() { return DIRECTIONS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ACTION_TYPES\", function() { return ACTION_TYPES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EFFECTS_STACKING\", function() { return EFFECTS_STACKING; });\nvar FRAMES_PER_SECOND = 30;\nvar SHORT_KEYPRESS_DURATION = 1;\nvar MODES = {\n  INITIALISING: 'initialising',\n  ACTION: 'action',\n  CYOA: 'choose your own adventure' // TODO: change this to 'NOVEL'\n\n};\nvar SHAPES = {\n  NONE: 'none',\n  CIRCLE: 'circle',\n  SQUARE: 'square',\n  POLYGON: 'polygon'\n};\nvar ROTATIONS = {\n  EAST: 0,\n  SOUTHEAST: Math.PI * 0.25,\n  SOUTH: Math.PI * 0.5,\n  SOUTHWEST: Math.PI * 0.75,\n  WEST: Math.PI,\n  NORTHWEST: Math.PI * -0.75,\n  NORTH: Math.PI * -0.5,\n  NORTHEAST: Math.PI * -0.25\n};\nvar DIRECTIONS = {\n  EAST: 0,\n  SOUTH: 1,\n  WEST: 2,\n  NORTH: 3\n};\nvar ACTION_TYPES = {\n  IDLE: 'idle',\n  // Default. Loops.\n  CONTINUOUS: 'continuous',\n  // Requires continuous input (e.g. moving). Loops until cancelled (e.g. user stops pressing arrow keys) or interrupted (e.g. by taking damage and going into the knockback state).\n  STANDARD: 'standard',\n  // Actions that play out all their steps. Cannot be cancelled by new user input. Can be interrupted.\n  SPECIAL_ONCE: 'special once',\n  // Actions that play out all their steps. Cannot be cancelled nor interrupted, except by story scripts.\n  SPECIAL_FOREVER: 'special forever' // Actions that play in a loop. Cannot be cancelled nor interrupted, except by story scripts.\n\n};\n/*\r\nStacking Rules determine what happens when a Particle's Effect payload is\r\napplied to an object that already has the same Effect.\r\n */\n\nvar EFFECTS_STACKING = {\n  STACK: 'stack',\n  // New Effects coexist with old Effects with the same name. \n  NEWEST: 'newest',\n  // Newest Effect overwrites older Effects with the same name.\n  OLDEST: 'oldest' // Old Effects won't be overwritten by new ones with the same name.\n\n};\n\n//# sourceURL=webpack:///./src/avo/misc/constants.js?");

/***/ }),

/***/ "./src/avo/misc/image-asset.js":
/*!*************************************!*\
  !*** ./src/avo/misc/image-asset.js ***!
  \*************************************/
/*! exports provided: ImageAsset */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ImageAsset\", function() { return ImageAsset; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ImageAsset = function ImageAsset(url) {\n  _classCallCheck(this, ImageAsset);\n\n  this.url = url;\n  this.img = null;\n  this.loaded = false;\n  this.img = new Image();\n\n  this.img.onload = function () {\n    this.loaded = true;\n  }.bind(this);\n\n  this.img.src = this.url;\n};\n\n//# sourceURL=webpack:///./src/avo/misc/image-asset.js?");

/***/ }),

/***/ "./src/avo/misc/physics.js":
/*!*********************************!*\
  !*** ./src/avo/misc/physics.js ***!
  \*********************************/
/*! exports provided: Physics */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Physics\", function() { return Physics; });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"./src/avo/misc/constants.js\");\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\nvar USE_CIRCLE_APPROXIMATION = false;\nvar Physics =\n/*#__PURE__*/\nfunction () {\n  function Physics() {\n    _classCallCheck(this, Physics);\n  }\n\n  _createClass(Physics, null, [{\n    key: \"checkCollision\",\n    //----------------------------------------------------------------\n\n    /*  Checks if objA is touching objB.\r\n        If true, returns the corrected coordinates for objA and objB, in form:\r\n          { ax, ay, bx, by }\r\n        If false, returns null.\r\n     */\n    value: function checkCollision(objA, objB) {\n      if (!objA || !objB || objA === objB) return null;\n\n      if (objA.shape === _constants__WEBPACK_IMPORTED_MODULE_0__[\"SHAPES\"].CIRCLE && objB.shape === _constants__WEBPACK_IMPORTED_MODULE_0__[\"SHAPES\"].CIRCLE) {\n        return Physics.checkCollision_circleCircle(objA, objB);\n      } else if ((objA.shape === _constants__WEBPACK_IMPORTED_MODULE_0__[\"SHAPES\"].SQUARE || objA.shape === _constants__WEBPACK_IMPORTED_MODULE_0__[\"SHAPES\"].POLYGON) && (objB.shape === _constants__WEBPACK_IMPORTED_MODULE_0__[\"SHAPES\"].SQUARE || objB.shape === _constants__WEBPACK_IMPORTED_MODULE_0__[\"SHAPES\"].POLYGON)) {\n        return Physics.checkCollision_polygonPolygon(objA, objB);\n      } else if (objA.shape === _constants__WEBPACK_IMPORTED_MODULE_0__[\"SHAPES\"].CIRCLE && (objB.shape === _constants__WEBPACK_IMPORTED_MODULE_0__[\"SHAPES\"].SQUARE || objB.shape === _constants__WEBPACK_IMPORTED_MODULE_0__[\"SHAPES\"].POLYGON)) {\n        if (USE_CIRCLE_APPROXIMATION) return Physics.checkCollision_polygonPolygon(objA, objB);\n        return Physics.checkCollision_circlePolygon(objA, objB);\n      } else if ((objA.shape === _constants__WEBPACK_IMPORTED_MODULE_0__[\"SHAPES\"].SQUARE || objA.shape === _constants__WEBPACK_IMPORTED_MODULE_0__[\"SHAPES\"].POLYGON) && objB.shape === _constants__WEBPACK_IMPORTED_MODULE_0__[\"SHAPES\"].CIRCLE) {\n        if (USE_CIRCLE_APPROXIMATION) return Physics.checkCollision_polygonPolygon(objA, objB);\n        var correction = Physics.checkCollision_circlePolygon(objB, objA);\n\n        if (correction) {\n          correction = {\n            ax: correction.bx,\n            ay: correction.by,\n            bx: correction.ax,\n            by: correction.ay\n          };\n        }\n\n        return correction;\n      }\n\n      return null;\n    } //----------------------------------------------------------------\n\n  }, {\n    key: \"checkCollision_circleCircle\",\n    value: function checkCollision_circleCircle(objA, objB) {\n      var fractionA = 0;\n      var fractionB = 0;\n\n      if (!objA.solid || !objB.solid) {//If either object isn't solid, there's no collision correction.\n      } else if (objA.movable && objB.movable) {\n        fractionA = 0.5;\n        fractionB = 0.5;\n      } else if (objA.movable) {\n        fractionA = 1;\n      } else if (objB.movable) {\n        fractionB = 1;\n      }\n\n      var distX = objB.x - objA.x;\n      var distY = objB.y - objA.y;\n      var dist = Math.sqrt(distX * distX + distY * distY);\n      var minimumDist = objA.radius + objB.radius;\n\n      if (dist < minimumDist) {\n        var angle = Math.atan2(distY, distX);\n        var correctDist = minimumDist;\n        var cosAngle = Math.cos(angle);\n        var sinAngle = Math.sin(angle);\n        return {\n          ax: objA.x - cosAngle * (correctDist - dist) * fractionA,\n          ay: objA.y - sinAngle * (correctDist - dist) * fractionA,\n          bx: objB.x + cosAngle * (correctDist - dist) * fractionB,\n          by: objB.y + sinAngle * (correctDist - dist) * fractionB\n        };\n      }\n\n      return null;\n    } //----------------------------------------------------------------\n\n  }, {\n    key: \"checkCollision_polygonPolygon\",\n    value: function checkCollision_polygonPolygon(objA, objB) {\n      var fractionA = 0;\n      var fractionB = 0;\n\n      if (!objA.solid || !objB.solid) {//If either object isn't solid, there's no collision correction.\n      } else if (objA.movable && objB.movable) {\n        fractionA = 0.5;\n        fractionB = 0.5;\n      } else if (objA.movable) {\n        fractionA = 1;\n      } else if (objB.movable) {\n        fractionB = 1;\n      }\n\n      var correction = null;\n      var verticesA = objA.vertices;\n      var verticesB = objB.vertices;\n      var projectionAxes = [].concat(_toConsumableArray(Physics.getShapeNormals(objA)), _toConsumableArray(Physics.getShapeNormals(objB)));\n\n      for (var i = 0; i < projectionAxes.length; i++) {\n        var axis = projectionAxes[i];\n        var projectionA = {\n          min: Infinity,\n          max: -Infinity\n        };\n        var projectionB = {\n          min: Infinity,\n          max: -Infinity\n        };\n\n        for (var j = 0; j < verticesA.length; j++) {\n          var val = Physics.dotProduct(axis, verticesA[j]);\n          projectionA.min = Math.min(projectionA.min, val);\n          projectionA.max = Math.max(projectionA.max, val);\n        }\n\n        for (var _j = 0; _j < verticesB.length; _j++) {\n          var _val = Physics.dotProduct(axis, verticesB[_j]);\n\n          projectionB.min = Math.min(projectionB.min, _val);\n          projectionB.max = Math.max(projectionB.max, _val);\n        }\n\n        var overlap = Math.max(0, Math.min(projectionA.max, projectionB.max) - Math.max(projectionA.min, projectionB.min));\n\n        if (!correction || overlap < correction.magnitude) {\n          var sign = Math.sign(projectionB.min + projectionB.max - (projectionA.min + projectionA.max));\n          correction = {\n            magnitude: overlap,\n            x: axis.x * overlap * sign,\n            y: axis.y * overlap * sign\n          };\n        }\n      }\n\n      if (correction && correction.magnitude > 0) {\n        return {\n          ax: objA.x - correction.x * fractionA,\n          ay: objA.y - correction.y * fractionA,\n          bx: objB.x + correction.x * fractionB,\n          by: objB.y + correction.y * fractionB\n        };\n      }\n\n      return null;\n    } //----------------------------------------------------------------\n\n  }, {\n    key: \"checkCollision_circlePolygon\",\n    value: function checkCollision_circlePolygon(objA, objB) {\n      var fractionA = 0;\n      var fractionB = 0;\n\n      if (!objA.solid || !objB.solid) {//If either object isn't solid, there's no collision correction.\n      } else if (objA.movable && objB.movable) {\n        fractionA = 0.5;\n        fractionB = 0.5;\n      } else if (objA.movable) {\n        fractionA = 1;\n      } else if (objB.movable) {\n        fractionB = 1;\n      }\n\n      var distX = objB.x - objA.x;\n      var distY = objB.y - objA.y;\n      var dist = Math.sqrt(distX * distX + distY * distY);\n      var angle = Math.atan2(distY, distX);\n      var centreToCentreAxis = dist !== 0 ? {\n        x: distX / dist,\n        y: distY / dist\n      } : {\n        x: 0,\n        y: 0\n      };\n      var correction = null;\n      var verticesB = objB.vertices;\n      var projectionAxes = [centreToCentreAxis].concat(_toConsumableArray(Physics.getShapeNormals(objB)));\n\n      for (var i = 0; i < projectionAxes.length; i++) {\n        var axis = projectionAxes[i];\n        var scalarA = Physics.dotProduct(axis, {\n          x: objA.x,\n          y: objA.y\n        });\n        var projectionA = {\n          min: scalarA - objA.radius,\n          max: scalarA + objA.radius\n        };\n        var projectionB = {\n          min: Infinity,\n          max: -Infinity\n        };\n\n        for (var j = 0; j < verticesB.length; j++) {\n          var val = Physics.dotProduct(axis, verticesB[j]);\n          projectionB.min = Math.min(projectionB.min, val);\n          projectionB.max = Math.max(projectionB.max, val);\n        }\n\n        var overlap = Math.max(0, Math.min(projectionA.max, projectionB.max) - Math.max(projectionA.min, projectionB.min));\n\n        if (!correction || overlap < correction.magnitude) {\n          var sign = Math.sign(projectionB.min + projectionB.max - (projectionA.min + projectionA.max));\n          correction = {\n            magnitude: overlap,\n            x: axis.x * overlap * sign,\n            y: axis.y * overlap * sign\n          };\n        }\n      }\n\n      if (correction && correction.magnitude > 0) {\n        return {\n          ax: objA.x - correction.x * fractionA,\n          ay: objA.y - correction.y * fractionA,\n          bx: objB.x + correction.x * fractionB,\n          by: objB.y + correction.y * fractionB\n        };\n      }\n    } //----------------------------------------------------------------\n\n    /*  Gets the NORMALISED normals for each edge of the object's shape. Assumes the object has the 'vertices' property.\r\n     */\n\n  }, {\n    key: \"getShapeNormals\",\n    value: function getShapeNormals(obj) {\n      var vertices = obj.vertices;\n      if (!vertices) return null;\n      if (vertices.length < 2) return []; //Look you need to have at least three vertices to be a shape.\n      //First, calculate the edges connecting each vertice.\n      //--------------------------------\n\n      var edges = [];\n\n      for (var i = 0; i < vertices.length; i++) {\n        var p1 = vertices[i];\n        var p2 = vertices[(i + 1) % vertices.length];\n        edges.push({\n          x: p2.x - p1.x,\n          y: p2.y - p1.y\n        });\n      } //--------------------------------\n      //Calculate the NORMALISED normals for each edge.\n      //--------------------------------\n\n\n      return edges.map(function (edge) {\n        var dist = Math.sqrt(edge.x * edge.x + edge.y * edge.y);\n        if (dist === 0) return {\n          x: 0,\n          y: 0\n        };\n        return {\n          x: -edge.y / dist,\n          y: edge.x / dist\n        };\n      }); //--------------------------------\n    } //----------------------------------------------------------------\n\n  }, {\n    key: \"dotProduct\",\n    value: function dotProduct(vectorA, vectorB) {\n      if (!vectorA || !vectorB) return null;\n      return vectorA.x * vectorB.x + vectorA.y * vectorB.y;\n    } //----------------------------------------------------------------\n\n  }]);\n\n  return Physics;\n}();\n\n//# sourceURL=webpack:///./src/avo/misc/physics.js?");

/***/ }),

/***/ "./src/avo/reactions/index.js":
/*!************************************!*\
  !*** ./src/avo/reactions/index.js ***!
  \************************************/
/*! exports provided: STANDARD_REACTIONS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"STANDARD_REACTIONS\", function() { return STANDARD_REACTIONS; });\nvar STANDARD_REACTIONS = {\n  DAMAGE: {\n    onAdd: function onAdd(app, actor, effect) {},\n    always: function always(app, actor, effect) {},\n    onRemove: function onRemove(app, actor, effect) {}\n  },\n  PUSH: {\n    onAdd: function onAdd(app, actor, effect) {\n      console.log('NEW PUSH!');\n    },\n    always: function always(app, actor, effect) {\n      var power = effect.attr && effect.attr.power || 0;\n      var angle = effect.attr && effect.attr.angle || 0;\n      actor.pushX += power * Math.cos(angle);\n      actor.pushY += power * Math.sin(angle);\n\n      if (effect.attr.decay && effect.attr.power) {\n        effect.attr.power = Math.max(effect.attr.power - effect.attr.decay, 0);\n      }\n    },\n    onRemove: function onRemove(app, actor, effect) {\n      console.log('PUSH FINISHED!');\n    }\n  }\n};\n\n//# sourceURL=webpack:///./src/avo/reactions/index.js?");

/***/ }),

/***/ "./src/avo/story-elements/actor.js":
/*!*****************************************!*\
  !*** ./src/avo/story-elements/actor.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/misc/constants */ \"./src/avo/misc/constants.js\");\n/* harmony import */ var _avo_actions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/actions */ \"./src/avo/actions/index.js\");\n/* harmony import */ var _avo_reactions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @avo/reactions */ \"./src/avo/reactions/index.js\");\n/* harmony import */ var _avo_animations__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @avo/animations */ \"./src/avo/animations/index.js\");\n/* harmony import */ var _story_element__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./story-element */ \"./src/avo/story-elements/story-element.js\");\n/* harmony import */ var _particle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./particle */ \"./src/avo/story-elements/particle.js\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n\n\n\nvar Actor =\n/*#__PURE__*/\nfunction (_StoryElement) {\n  _inherits(Actor, _StoryElement);\n\n  function Actor(app) {\n    var _this;\n\n    var initialValues = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Actor);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Actor).call(this, app));\n    _this.shape = _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"SHAPES\"].CIRCLE;\n    _this.solid = true;\n    _this.movable = true;\n    _this.stats = {\n      health: 100,\n      // TEMP\n      maxHealth: 100,\n      // TEMP\n      acceleration: 1,\n      deceleration: 1,\n      maxSpeed: 8\n    };\n    _this.intent = undefined;\n    _this.actionName = 'idle';\n    _this.actionAttr = {};\n    _this.actionStep = 0;\n    _this.actions = {\n      'idle': _avo_actions__WEBPACK_IMPORTED_MODULE_1__[\"STANDARD_ACTIONS\"].IDLE,\n      'move': _avo_actions__WEBPACK_IMPORTED_MODULE_1__[\"STANDARD_ACTIONS\"].MOVE,\n      'attack': _avo_actions__WEBPACK_IMPORTED_MODULE_1__[\"STANDARD_ACTIONS\"].ATTACK\n    };\n    _this.scripts = {\n      'always': function always(app, actor) {}\n    };\n    _this.reactions = {\n      'damage': _avo_reactions__WEBPACK_IMPORTED_MODULE_2__[\"STANDARD_REACTIONS\"].DAMAGE,\n      'push': _avo_reactions__WEBPACK_IMPORTED_MODULE_2__[\"STANDARD_REACTIONS\"].PUSH\n    };\n    _this.animationScript = _avo_animations__WEBPACK_IMPORTED_MODULE_3__[\"STANDARD_ANIMATIONS\"].ACTOR; // Set initial values\n\n    Object.assign(_assertThisInitialized(_this), initialValues);\n    return _this;\n  }\n\n  _createClass(Actor, [{\n    key: \"play\",\n    value: function play() {\n      var app = this._app; // Run script: \"always execute on every frame\"\n\n      this.scripts.always && this.scripts.always(app, this); // TODO: copy processEffects to Particles, too.\n\n      this.processEffects();\n      this.processIntent();\n      this.processActions(); // TODO // TEMP - move this into this.scripts.always() ?\n\n      if (this.stats.health <= 0) {\n        this._expired = true;\n      }\n\n      if (this.stats.health < this.stats.maxHealth) {\n        this.stats.health += 0.05;\n      } // Upkeep: deceleration\n\n\n      if (this.actionName !== 'move') {\n        var deceleration = this.stats.deceleration || 0;\n        var curRotation = Math.atan2(this.moveY, this.moveX);\n        var curMoveSpeed = Math.sqrt(this.moveX * this.moveX + this.moveY * this.moveY);\n        var newMoveSpeed = Math.max(0, curMoveSpeed - deceleration);\n        this.moveX = newMoveSpeed * Math.cos(curRotation);\n        this.moveY = newMoveSpeed * Math.sin(curRotation);\n      }\n    }\n  }, {\n    key: \"processIntent\",\n    value: function processIntent() {\n      // Translate intent into action.\n      var action = this.actions[this.actionName];\n\n      if (!action) {\n        // Sanity check: if the Actor isn't doing anything, go idle.\n        this.goIdle(); // This is just a failsafe - the actor should ALWAYS have an action, even if it's the IDLE action.\n      } else if (!this.intent) {\n        // If the Actor has no intent (e.g. player has no key input)...\n        // ...cancel any currently cancellable actions.\n        // (Obviously, ignore this if the \n        if (action.type === _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION_TYPES\"].CONTINUOUS) this.goIdle();\n      } else {\n        // Actor intends to perform a new action.\n        // First, can the current action be overwritten by a new action?\n        if (action.type === _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION_TYPES\"].IDLE || action.type === _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION_TYPES\"].CONTINUOUS) {\n          // Second, check if the new action is different from the old one. \n          // Reset the actionStep counter if that's the case.\n          if (this.actionName !== this.intent.name) {\n            this.actionStep = 0;\n          } // Finally, convert the intent into the new action.\n\n\n          this.actionName = this.intent.name;\n          this.actionAttr = this.intent.attr ? _objectSpread({}, this.intent.attr) : {};\n        }\n      }\n    }\n  }, {\n    key: \"goIdle\",\n    value: function goIdle() {\n      this.actionName = 'idle';\n      this.actionStep = 0;\n      this.actionAttr = {};\n    }\n  }, {\n    key: \"processEffects\",\n    value: function processEffects() {\n      var _this2 = this;\n\n      var app = this._app;\n      this.effects.forEach(function (effect) {\n        var reaction = _this2.reactions[effect.name] || {}; // For each active Effect, run a reaction.\n\n        if (effect.duration > 0) {\n          reaction.always && reaction.always(app, _this2, effect);\n        } // Effects should decay (unless duration === Infinity, of course) \n\n\n        effect.duration--; // Prepare to end any old effects.\n\n        if (effect.duration <= 0) reaction.onRemove && reaction.onRemove(app, _this2, effect);\n      }); // Remove old effects\n\n      this.effects = this.effects.filter(function (effect) {\n        return effect.duration > 0;\n      });\n    }\n  }, {\n    key: \"processActions\",\n    value: function processActions() {\n      var app = this._app;\n      var action = this.actions[this.actionName];\n      if (!action) return;\n      action.script(app, this, action, this.actionAttr, this.actionStep);\n      this.actionStep += 1;\n\n      if (this.actionStep >= action.steps) {\n        // Is the action over?\n        this.actionStep = 0; // If it's over (and doesn't loop), revert to default.\n\n        if (action.type === _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION_TYPES\"].STANDARD || action.type === _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION_TYPES\"].SPECIAL_ONCE) {\n          this.goIdle();\n        }\n      }\n    }\n  }]);\n\n  return Actor;\n}(_story_element__WEBPACK_IMPORTED_MODULE_4__[\"default\"]);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Actor);\n\n//# sourceURL=webpack:///./src/avo/story-elements/actor.js?");

/***/ }),

/***/ "./src/avo/story-elements/particle.js":
/*!********************************************!*\
  !*** ./src/avo/story-elements/particle.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/misc/constants */ \"./src/avo/misc/constants.js\");\n/* harmony import */ var _story_element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./story-element */ \"./src/avo/story-elements/story-element.js\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\nvar COLLISION_SPACING = _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"FRAMES_PER_SECOND\"] / 2;\n\nvar Particle =\n/*#__PURE__*/\nfunction (_StoryElement) {\n  _inherits(Particle, _StoryElement);\n\n  function Particle(app, initialValues) {\n    var _this;\n\n    _classCallCheck(this, Particle);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Particle).call(this, app));\n    _this.shape = _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"SHAPES\"].CIRCLE;\n    _this.scripts = {\n      'always': function always(app, particle) {},\n      'collision': function collision(app, particle, target) {}\n    }; // Particles can have a limited duration.\n\n    _this.duration = Infinity; // When applying effects on collision, Particles can ignore their source\n    // (the Actor that created it), if any.\n    // (e.g. sword swings shouldn't hit their wielder. Nobody's that clumsy.)\n\n    _this.source = undefined;\n    _this.ignoreSource = false; // When applying effects on collision, Particles shouldn't hit the same\n    // targets perpetually every single frame.\n\n    _this.recentTargets = []; // Set initial values\n\n    Object.assign(_assertThisInitialized(_this), initialValues);\n    return _this;\n  }\n\n  _createClass(Particle, [{\n    key: \"play\",\n    value: function play() {\n      var app = this._app; // Run script: \"always execute on every frame\"\n\n      this.scripts.always && this.scripts.always(app, this); // Perform upkeep on the list of recent targets:\n      // Tick down the recent target's duration, then remove any that has 0 duration.\n\n      this.recentTargets = this.recentTargets.filter(function (item) {\n        return --item.duration > 0;\n      }); // Tick down the duration and remove if the timer runs out.\n      // Note that if duration === Infinity, the Particle is permanent.\n\n      this.duration--;\n      if (this.duration < 0) this._expired = true;\n    }\n  }, {\n    key: \"onCollision\",\n    value: function onCollision(target, collisionCorrection) {\n      var app = this._app;\n      var targetIsValid = !!target // Is there a target?\n      && !(this.ignoreSource && this.source === target) // If the target is the source of the Particle, ignore it?\n      && !this.recentTargets.find(function (t) {\n        return t.target === target;\n      });\n\n      if (targetIsValid) {\n        // Run script: particle collided with a target\n        this.scripts.collision && this.scripts.collision(app, this, target); // Add to the list of recent targets, so targets aren't hit back to back to back.\n\n        this.recentTargets.push({\n          target: target,\n          duration: COLLISION_SPACING\n        });\n      }\n    }\n  }, {\n    key: \"applyEffect\",\n    value: function applyEffect(effect, target) {\n      if (!effect || !target) return;\n      var shouldApply = !!target.reactions[effect.name]; // Does the target have a script to react to this effect?\n      // TODO: check on effects stacking.\n      // const existingEffect = target.effects.find(eff => eff.name === effect.name);\n\n      if (shouldApply) {\n        // Prepare to add new effect\n        var reaction = target.reactions[effect.name] || {};\n        reaction.onAdd && reaction.onAdd(app, target, effect);\n        target.effects.push(effect);\n      }\n    }\n  }]);\n\n  return Particle;\n}(_story_element__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Particle);\n\n//# sourceURL=webpack:///./src/avo/story-elements/particle.js?");

/***/ }),

/***/ "./src/avo/story-elements/story-element.js":
/*!*************************************************!*\
  !*** ./src/avo/story-elements/story-element.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/misc/constants */ \"./src/avo/misc/constants.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar StoryElement =\n/*#__PURE__*/\nfunction () {\n  // TODO: rename to just 'Element' or 'Entity'?\n  function StoryElement(app) {\n    _classCallCheck(this, StoryElement);\n\n    this._app = app; // Expired elements are removed at the end of the cycle.\n\n    this._expired = false;\n    this.stats = {};\n    this.x = 0;\n    this.y = 0;\n    this.size = 32; // TODO: this.z = 1;\n\n    this._rotation = _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"ROTATIONS\"].SOUTH; // Rotation in radians\n    // Movement: self locomotion and external (pushed) movement.\n\n    this.moveX = 0;\n    this.moveY = 0;\n    this.pushX = 0;\n    this.pushY = 0;\n    this.shape = _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"SHAPES\"].NONE;\n    this.shapePolygonPath = null; // Only applicable if shape === SHAPES.POLYGON\n\n    this.solid = false;\n    this.movable = false;\n    this.animationName = 'idle';\n    this.animationSpritesheet = null;\n\n    this.animationScript = function (app, element, canvas) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    };\n\n    this.scripts = {}; // Custom scripts, e.g. actor.scripts.always runs on every frame.\n\n    this.effects = []; // Effects applied to the Actor/Particle/etc.\n\n    this.reactions = {}; // Reaction scripts; tells what the Actor/Particle/etc should do when they receive an Effect.\n  }\n\n  _createClass(StoryElement, [{\n    key: \"play\",\n    value: function play() {}\n  }, {\n    key: \"paint\",\n    value: function paint(canvas, camera) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      // TODO: see https://www.html5rocks.com/en/tutorials/canvas/hidpi/ about using window.devicePixelRatio to fix blurriness on a High DPI canvas\n      this.animationScript && this.animationScript(this._app, this, canvas, camera, options);\n    }\n  }, {\n    key: \"onCollision\",\n    value: function onCollision(target, collisionCorrection) {}\n  }, {\n    key: \"left\",\n    get: function get() {\n      return this.x - this.size / 2;\n    },\n    set: function set(val) {\n      this.x = val + this.size / 2;\n    }\n  }, {\n    key: \"right\",\n    get: function get() {\n      return this.x + this.size / 2;\n    },\n    set: function set(val) {\n      this.x = val - this.size / 2;\n    }\n  }, {\n    key: \"top\",\n    get: function get() {\n      return this.y - this.size / 2;\n    },\n    set: function set(val) {\n      this.y = val + this.size / 2;\n    }\n  }, {\n    key: \"bottom\",\n    get: function get() {\n      return this.y + this.size / 2;\n    },\n    set: function set(val) {\n      this.y = val - this.size / 2;\n    }\n  }, {\n    key: \"radius\",\n    get: function get() {\n      return this.size / 2;\n    },\n    set: function set(val) {\n      this.size = val * 2;\n    }\n  }, {\n    key: \"rotation\",\n    get: function get() {\n      return this._rotation;\n    },\n    set: function set(val) {\n      this._rotation = val;\n\n      while (this._rotation > Math.PI) {\n        this._rotation -= Math.PI * 2;\n      }\n\n      while (this._rotation <= -Math.PI) {\n        this._rotation += Math.PI * 2;\n      }\n    }\n  }, {\n    key: \"direction\",\n    get: function get() {\n      //Get cardinal direction\n      //Favour East and West when rotation is exactly SW, NW, SE or NE.\n      if (this._rotation <= Math.PI * 0.25 && this._rotation >= Math.PI * -0.25) {\n        return _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"DIRECTIONS\"].EAST;\n      } else if (this._rotation > Math.PI * 0.25 && this._rotation < Math.PI * 0.75) {\n        return _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"DIRECTIONS\"].SOUTH;\n      } else if (this._rotation < Math.PI * -0.25 && this._rotation > Math.PI * -0.75) {\n        return _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"DIRECTIONS\"].NORTH;\n      } else {\n        return _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"DIRECTIONS\"].WEST;\n      }\n    },\n    set: function set(val) {\n      switch (val) {\n        case _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"DIRECTIONS\"].EAST:\n          this._rotation = _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"ROTATIONS\"].EAST;\n          break;\n\n        case _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"DIRECTIONS\"].SOUTH:\n          this._rotation = _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"ROTATIONS\"].SOUTH;\n          break;\n\n        case _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"DIRECTIONS\"].WEST:\n          this._rotation = _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"ROTATIONS\"].WEST;\n          break;\n\n        case _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"DIRECTIONS\"].NORTH:\n          this._rotation = _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"ROTATIONS\"].NORTH;\n          break;\n      }\n    }\n  }, {\n    key: \"vertices\",\n    get: function get() {\n      var _this = this;\n\n      var v = [];\n\n      if (this.shape === _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"SHAPES\"].SQUARE) {\n        v.push({\n          x: this.left,\n          y: this.top\n        });\n        v.push({\n          x: this.right,\n          y: this.top\n        });\n        v.push({\n          x: this.right,\n          y: this.bottom\n        });\n        v.push({\n          x: this.left,\n          y: this.bottom\n        });\n      } else if (this.shape === _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"SHAPES\"].CIRCLE) {\n        //Approximation\n        CIRCLE_TO_POLYGON_APPROXIMATOR.map(function (approximator) {\n          v.push({\n            x: _this.x + _this.radius * approximator.cosAngle,\n            y: _this.y + _this.radius * approximator.sinAngle\n          });\n        });\n      } else if (this.shape === _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"SHAPES\"].POLYGON) {\n        if (!this.shapePolygonPath) return [];\n\n        for (var i = 0; i < this.shapePolygonPath.length; i += 2) {\n          v.push({\n            x: this.x + this.shapePolygonPath[i],\n            y: this.y + this.shapePolygonPath[i + 1]\n          });\n        }\n      }\n\n      return v;\n    }\n  }]);\n\n  return StoryElement;\n}();\n\nvar CIRCLE_TO_POLYGON_APPROXIMATOR = [_avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"ROTATIONS\"].EAST, _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"ROTATIONS\"].SOUTHEAST, _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"ROTATIONS\"].SOUTH, _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"ROTATIONS\"].SOUTHWEST, _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"ROTATIONS\"].WEST, _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"ROTATIONS\"].NORTHWEST, _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"ROTATIONS\"].NORTH, _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"ROTATIONS\"].NORTHEAST].map(function (angle) {\n  return {\n    cosAngle: Math.cos(angle),\n    sinAngle: Math.sin(angle)\n  };\n});\n/* harmony default export */ __webpack_exports__[\"default\"] = (StoryElement);\n\n//# sourceURL=webpack:///./src/avo/story-elements/story-element.js?");

/***/ }),

/***/ "./src/avo/story.js":
/*!**************************!*\
  !*** ./src/avo/story.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/misc/constants */ \"./src/avo/misc/constants.js\");\n/* harmony import */ var _avo_misc_image_asset__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/misc/image-asset */ \"./src/avo/misc/image-asset.js\");\n/* harmony import */ var _avo_story_elements_actor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @avo/story-elements/actor */ \"./src/avo/story-elements/actor.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\nvar Story =\n/*#__PURE__*/\nfunction () {\n  function Story(app) {\n    _classCallCheck(this, Story);\n\n    this._app = app; // Assets\n\n    app.assets.basicActor = new _avo_misc_image_asset__WEBPACK_IMPORTED_MODULE_1__[\"ImageAsset\"]('assets/actor-v2.png');\n    app.playerActor = new _avo_story_elements_actor__WEBPACK_IMPORTED_MODULE_2__[\"default\"](app, {\n      x: 32 * 4.5,\n      y: 32 * 2.5,\n      size: 32,\n      animationSpritesheet: app.assets.basicActor\n    });\n    app.actors.push(app.playerActor);\n    var testActorA = new _avo_story_elements_actor__WEBPACK_IMPORTED_MODULE_2__[\"default\"](app, {\n      x: 32 * 6.5,\n      y: 32 * 2.5,\n      size: 32,\n      animationSpritesheet: app.assets.basicActor\n    });\n    app.actors.push(testActorA); // Set camera to follow player actor\n\n    app.camera.targetActor = app.playerActor; // TODO:\n    // app.addActor();\n    // app.addAsset();\n  }\n\n  _createClass(Story, [{\n    key: \"start\",\n    value: function start() {\n      var app = this._app;\n      console.info('STORY IS READY TO START!');\n      app.changeMode(_avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"MODES\"].ACTION);\n    }\n  }, {\n    key: \"skipPlay\",\n    value: function skipPlay() {\n      return false;\n    }\n  }, {\n    key: \"customPlay\",\n    value: function customPlay() {}\n  }, {\n    key: \"skipPaint\",\n    value: function skipPaint() {\n      return false;\n    }\n  }, {\n    key: \"customPaint\",\n    value: function customPaint() {}\n  }]);\n\n  return Story;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Story);\n\n//# sourceURL=webpack:///./src/avo/story.js?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _avo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./avo */ \"./src/avo/index.js\");\n\n\nwindow.onload = function () {\n  window.app = new _avo__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n};\n\n//# sourceURL=webpack:///./src/main.js?");

/***/ })

/******/ });