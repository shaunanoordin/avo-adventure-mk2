/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/avo/action-mode/action-mode.js":
/*!********************************************!*\
  !*** ./src/avo/action-mode/action-mode.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/misc/constants */ \"./src/avo/misc/constants.js\");\n/* harmony import */ var _avo_misc_physics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/misc/physics */ \"./src/avo/misc/physics.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\nvar ActionMode = /*#__PURE__*/function () {\n  function ActionMode(app) {\n    _classCallCheck(this, ActionMode);\n\n    this._app = app;\n    this.html = document.getElementById('action-mode');\n    this.width = 320;\n    this.height = 240;\n    this.canvas2d = this.html.getContext(\"2d\"); // Set HTML\n\n    this.html.width = this.width;\n    this.html.height = this.height;\n    this.canvasSizeRatio = 1;\n    this.html.onkeydown = this.onKeyDown.bind(this);\n    this.html.onkeyup = this.onKeyUp.bind(this); // Keys that are currently being pressed, and the number of frames they've\n    // been pressed for.\n\n    this.keysPressed = {};\n  }\n\n  _createClass(ActionMode, [{\n    key: \"load\",\n    value: function load() {\n      this.focus();\n    }\n  }, {\n    key: \"unload\",\n    value: function unload() {\n      this.resetKeysPressed();\n    }\n  }, {\n    key: \"focus\",\n    value: function focus() {\n      this.html.focus();\n    }\n  }, {\n    key: \"play\",\n    value: function play(timeStep) {\n      var _this = this;\n\n      var app = this._app;\n      this.processPlayerInput(); // Sort for visual rendering\n      // TODO: check if this is necessary.\n\n      function sortY(a, b) {\n        return a.y - b.y;\n      }\n\n      app.actors.sort(sortY);\n      app.particles.sort(sortY); // Run logic for each Entity\n\n      app.actors.forEach(function (actor) {\n        actor.play(timeStep);\n      });\n      app.particles.forEach(function (particle) {\n        particle.play(timeStep);\n      });\n      this.processPhysics(timeStep); // Camera Controls: focus the camera on the target actor, if any.\n\n      if (app.camera.targetActor) {\n        app.camera.x = this.width / 2 - app.camera.targetActor.x;\n        app.camera.y = this.height / 2 - app.camera.targetActor.y;\n      } // DEBUG // TEST\n\n\n      if (this.keysPressed['Escape'] === _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"SHORT_KEYPRESS_DURATION\"]) {\n        app.changeMode(_avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"MODES\"].INTERACTION);\n      } // Increment the duration of each currently pressed key\n\n\n      Object.keys(this.keysPressed).forEach(function (key) {\n        if (_this.keysPressed[key]) _this.keysPressed[key]++;\n      });\n    }\n  }, {\n    key: \"paint\",\n    value: function paint() {\n      // TODO: see https://www.html5rocks.com/en/tutorials/canvas/hidpi/ about using window.devicePixelRatio to fix blurriness on a High DPI canvas\n      var app = this._app;\n      var canvas2d = this.canvas2d;\n      var camera = app.camera; // Clear canvas before painting\n\n      canvas2d.clearRect(0, 0, this.width, this.height); // Paint the map (floor)\n\n      app.map && app.map.paint(canvas2d, camera, {}); // Paint each Entity\n\n      app.particles.forEach(function (particle) {\n        particle.paint(canvas2d, camera, {});\n      });\n      app.actors.forEach(function (actor) {\n        actor.paint(canvas2d, camera, {});\n      });\n    }\n  }, {\n    key: \"focus\",\n    value: function focus() {\n      this.html.focus();\n    }\n  }, {\n    key: \"onKeyDown\",\n    value: function onKeyDown(e) {\n      if (!this.keysPressed[e.key]) this.keysPressed[e.key] = 1;\n    }\n  }, {\n    key: \"onKeyUp\",\n    value: function onKeyUp(e) {\n      this.keysPressed[e.key] = undefined;\n    }\n  }, {\n    key: \"resetKeysPressed\",\n    value: function resetKeysPressed() {\n      var _this2 = this;\n\n      Object.keys(this.keysPressed).forEach(function (key) {\n        _this2.keysPressed[key] = undefined;\n      });\n    }\n  }, {\n    key: \"processPlayerInput\",\n    value: function processPlayerInput() {\n      var app = this._app;\n      var playerActor = app.playerActor;\n\n      if (playerActor) {\n        playerActor.intent = undefined;\n        var moveX = 0;\n        var moveY = 0;\n        if (this.keysPressed['ArrowRight']) moveX++;\n        if (this.keysPressed['ArrowDown']) moveY++;\n        if (this.keysPressed['ArrowLeft']) moveX--;\n        if (this.keysPressed['ArrowUp']) moveY--;\n\n        if (this.keysPressed['z'] === _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"SHORT_KEYPRESS_DURATION\"] || this.keysPressed['Z'] === _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"SHORT_KEYPRESS_DURATION\"] || this.keysPressed[' '] === _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"SHORT_KEYPRESS_DURATION\"]) {\n          playerActor.intent = {\n            name: 'attack'\n          };\n        } else if (this.keysPressed['x'] === _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"SHORT_KEYPRESS_DURATION\"] || this.keysPressed['X'] === _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"SHORT_KEYPRESS_DURATION\"] || this.keysPressed['Shift'] === _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"SHORT_KEYPRESS_DURATION\"]) {\n          playerActor.intent = {\n            name: 'dash'\n          };\n        } else if (moveX || moveY) {\n          playerActor.intent = {\n            name: 'move',\n            attr: {\n              x: moveX,\n              y: moveY\n            }\n          };\n        }\n      }\n    }\n    /*\r\n    Run Physics logic, notably in regards to motion and collision.\r\n    \r\n    Note: we're simulating physics with discrete time intervals (i.e. video game\r\n    frames-per-second) for simplicity, instead of calculating for continuous time\r\n    (i.e. more realistic physics).\r\n    \r\n    Please don't expect too much mathematical realism here, but as long as the\r\n    actual time interval (timeStep) matches the expected time interval, the video\r\n    game logic will work.\r\n    */\n\n  }, {\n    key: \"processPhysics\",\n    value: function processPhysics(timeStep) {\n      var app = this._app;\n      var timeCorrection = timeStep / _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"EXPECTED_TIMESTEP\"]; // Move Actors and Particles\n\n      app.actors.forEach(function (actor) {\n        actor.x += actor.moveX * timeCorrection;\n        actor.y += actor.moveY * timeCorrection;\n        actor.x += actor.pushX * timeCorrection;\n        actor.y += actor.pushY * timeCorrection;\n        actor.pushX = 0;\n        actor.pushY = 0;\n      });\n      app.particles.forEach(function (particle) {\n        particle.x += particle.moveX * timeCorrection;\n        particle.y += particle.moveY * timeCorrection;\n        particle.x += particle.pushX * timeCorrection;\n        particle.y += particle.pushY * timeCorrection;\n        particle.pushX = 0;\n        particle.pushY = 0;\n      }); // Check Map tiles\n\n      var map = app.map;\n      app.actors.forEach(function (actor) {\n        var collisionCorrection = map.checkCollision(actor);\n\n        if (collisionCorrection) {\n          actor.x = collisionCorrection.x;\n          actor.y = collisionCorrection.y;\n        }\n      }); // Check Actor collisions\n\n      for (var a = 0; a < app.actors.length; a++) {\n        var actorA = app.actors[a]; // ...with other Actors\n\n        for (var b = a + 1; b < app.actors.length; b++) {\n          var actorB = app.actors[b];\n          var collisionCorrection = _avo_misc_physics__WEBPACK_IMPORTED_MODULE_1__[\"Physics\"].checkCollision(actorA, actorB);\n\n          if (collisionCorrection) {\n            actorA.x = collisionCorrection.ax;\n            actorA.y = collisionCorrection.ay;\n            actorB.x = collisionCorrection.bx;\n            actorB.y = collisionCorrection.by;\n            actorA.onCollision(actorB, collisionCorrection);\n            actorB.onCollision(actorA, collisionCorrection);\n          }\n        }\n      } // Check Particle collisions\n\n\n      for (var _a = 0; _a < app.particles.length; _a++) {\n        var particleA = app.particles[_a]; // ...with other Particles\n\n        for (var _b = _a + 1; _b < app.particles.length; _b++) {\n          var particleB = app.particles[_b];\n\n          var _collisionCorrection = _avo_misc_physics__WEBPACK_IMPORTED_MODULE_1__[\"Physics\"].checkCollision(particleA, particleB);\n\n          if (_collisionCorrection) {\n            particleA.onCollision(particleB, _collisionCorrection);\n            particleB.onCollision(particleA, _collisionCorrection);\n          }\n        } // ...with Actors\n\n\n        for (var _b2 = 0; _b2 < app.actors.length; _b2++) {\n          var _actorB = app.actors[_b2];\n\n          var _collisionCorrection2 = _avo_misc_physics__WEBPACK_IMPORTED_MODULE_1__[\"Physics\"].checkCollision(particleA, _actorB);\n\n          if (_collisionCorrection2) {\n            particleA.onCollision(_actorB, _collisionCorrection2);\n\n            _actorB.onCollision(particleA, _collisionCorrection2);\n          }\n        }\n      }\n    }\n  }]);\n\n  return ActionMode;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (ActionMode);\n\n//# sourceURL=webpack:///./src/avo/action-mode/action-mode.js?");

/***/ }),

/***/ "./src/avo/action-mode/index.js":
/*!**************************************!*\
  !*** ./src/avo/action-mode/index.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _action_mode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./action-mode */ \"./src/avo/action-mode/action-mode.js\");\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (_action_mode__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack:///./src/avo/action-mode/index.js?");

/***/ }),

/***/ "./src/avo/actions/index.js":
/*!**********************************!*\
  !*** ./src/avo/actions/index.js ***!
  \**********************************/
/*! exports provided: STANDARD_ACTIONS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"STANDARD_ACTIONS\", function() { return STANDARD_ACTIONS; });\n/* harmony import */ var _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/misc/constants */ \"./src/avo/misc/constants.js\");\n/* harmony import */ var _avo_animations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/animations */ \"./src/avo/animations/index.js\");\n/* harmony import */ var _avo_entities_particle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @avo/entities/particle */ \"./src/avo/entities/particle.js\");\n\n\n\nvar STANDARD_ACTIONS = {\n  IDLE: {\n    type: _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION_TYPES\"].IDLE,\n    duration: 1,\n    script: function script(_ref) {\n      var app = _ref.app,\n          entity = _ref.entity,\n          action = _ref.action,\n          actionAttr = _ref.actionAttr,\n          progress = _ref.progress,\n          timeStep = _ref.timeStep;\n      entity.animationName = 'idle';\n    }\n  },\n  MOVE: {\n    type: _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION_TYPES\"].CONTINUOUS,\n    duration: 500,\n    script: function script(_ref2) {\n      var app = _ref2.app,\n          entity = _ref2.entity,\n          action = _ref2.action,\n          actionAttr = _ref2.actionAttr,\n          progress = _ref2.progress,\n          timeStep = _ref2.timeStep;\n      var moveAcceleration = entity.moveAcceleration * timeStep / 1000 || 0;\n      var actionRotation = Math.atan2(actionAttr.y, actionAttr.x);\n      var moveX = entity.moveX + moveAcceleration * Math.cos(actionRotation);\n      var moveY = entity.moveY + moveAcceleration * Math.sin(actionRotation);\n\n      if (entity.moveMaxSpeed >= 0) {\n        var moveMaxSpeed = entity.moveMaxSpeed;\n        var correctedSpeed = Math.min(moveMaxSpeed, Math.sqrt(moveX * moveX + moveY * moveY));\n        var moveRotation = Math.atan2(moveY, moveX);\n        moveX = correctedSpeed * Math.cos(moveRotation);\n        moveY = correctedSpeed * Math.sin(moveRotation);\n      }\n\n      entity.moveX = moveX;\n      entity.moveY = moveY;\n      entity.rotation = actionRotation;\n      if (0 <= progress && progress < 0.25) entity.animationName = 'move-1';else if (0.25 <= progress && progress < 0.50) entity.animationName = 'move-2';else if (0.50 <= progress && progress < 0.75) entity.animationName = 'move-1';else if (0.75 <= progress && progress <= 1) entity.animationName = 'move-3';\n    }\n  },\n  ATTACK: {\n    type: _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION_TYPES\"].STANDARD,\n    duration: 1000,\n    script: function script(_ref3) {\n      var app = _ref3.app,\n          entity = _ref3.entity,\n          action = _ref3.action,\n          actionAttr = _ref3.actionAttr,\n          progress = _ref3.progress,\n          timeStep = _ref3.timeStep;\n\n      if (progress < 0.6) {\n        actionAttr.triggered = false;\n        entity.animationName = 'attack-windup';\n      } else if (progress >= 0.6 && !actionAttr.triggered) {\n        actionAttr.triggered = true;\n        var particle = new _avo_entities_particle__WEBPACK_IMPORTED_MODULE_2__[\"default\"](app, {\n          x: entity.x + Math.cos(entity.rotation) * entity.size * 0.8,\n          y: entity.y + Math.sin(entity.rotation) * entity.size * 0.8,\n          size: entity.size * 1,\n          duration: 1000,\n          source: entity,\n          ignoreSource: true,\n          attr: {\n            attackPower: 20,\n            pushPower: 100,\n            pushAngle: entity.rotation,\n            pushDuration: 1000,\n            pushDecay: 100\n          },\n          payloadScript: function payloadScript(_ref4) {\n            var app = _ref4.app,\n                entity = _ref4.entity,\n                target = _ref4.target;\n\n            if (target && target.attr) {\n              target.attr.health = Math.max((target.attr.health || 0) - particle.attr.attackPower, 0);\n              particle.applyEffect({\n                name: 'push',\n                attr: {\n                  power: particle.attr.pushPower,\n                  angle: particle.attr.pushAngle,\n                  decay: particle.attr.pushDecay\n                },\n                duration: particle.attr.pushDuration,\n                stacking: _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"EFFECTS_STACKING\"].STACK\n              }, target);\n            }\n          },\n          animationScript: _avo_animations__WEBPACK_IMPORTED_MODULE_1__[\"STANDARD_ANIMATIONS\"].PARTICLE\n        });\n        app.particles.push(particle);\n        entity.animationName = 'attack-active';\n      } else {\n        entity.animationName = 'attack-winddown';\n      }\n    }\n  },\n  DASH: {\n    type: _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION_TYPES\"].STANDARD,\n    duration: 200,\n    script: function script(_ref5) {\n      var app = _ref5.app,\n          entity = _ref5.entity,\n          action = _ref5.action,\n          actionAttr = _ref5.actionAttr,\n          progress = _ref5.progress,\n          timeStep = _ref5.timeStep;\n      entity.animationName = 'dash';\n      var power = entity.moveMaxSpeed ? entity.moveMaxSpeed * 3 * (1 - progress) : 0;\n      entity.pushX += power * Math.cos(entity.rotation);\n      entity.pushY += power * Math.sin(entity.rotation);\n    }\n  }\n};\n\n//# sourceURL=webpack:///./src/avo/actions/index.js?");

/***/ }),

/***/ "./src/avo/animations/index.js":
/*!*************************************!*\
  !*** ./src/avo/animations/index.js ***!
  \*************************************/
/*! exports provided: STANDARD_ANIMATIONS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"STANDARD_ANIMATIONS\", function() { return STANDARD_ANIMATIONS; });\n/* harmony import */ var _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/misc/constants */ \"./src/avo/misc/constants.js\");\n\nvar STANDARD_ANIMATIONS = {\n  ACTOR: function ACTOR(app, entity, canvas, camera) {\n    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    var layer = options.layer || '';\n    if (!canvas || !camera) return; // Simple shadow\n\n    canvas.fillStyle = 'rgba(0, 0, 0, 0.5)'; // --------\n    // Temporary 'animation'\n\n    if (entity.animationName === 'idle') canvas.fillStyle = 'rgba(0, 0, 0, 0.5)';else if (entity.animationName === 'move-1') canvas.fillStyle = 'rgba(0, 128, 128, 0.5)';else if (entity.animationName === 'move-2') canvas.fillStyle = 'rgba(0, 160, 128, 0.5)';else if (entity.animationName === 'move-3') canvas.fillStyle = 'rgba(0, 128, 160, 0.5)';else if (entity.animationName === 'attack-windup') canvas.fillStyle = 'rgba(192, 192, 0, 0.5)';else if (entity.animationName === 'attack-active') canvas.fillStyle = 'rgba(255, 0, 0, 0.5)';else if (entity.animationName === 'attack-winddown') canvas.fillStyle = 'rgba(192, 128, 0, 0.5)'; // --------\n\n    canvas.beginPath();\n    canvas.arc(Math.floor(entity.x + camera.x), Math.floor(entity.y + camera.y), entity.size / 2, 0, 2 * Math.PI);\n    canvas.fill(); // Simple direction\n    // --------\n\n    canvas.strokeStyle = 'rgba(0, 0, 0, 0.5)';\n    canvas.lineWidth = 2;\n    canvas.beginPath();\n    canvas.moveTo(Math.floor(entity.x + camera.x), Math.floor(entity.y + camera.y));\n    canvas.lineTo(Math.floor(entity.x + camera.x) + Math.cos(entity.rotation) * entity.size * 0.6, Math.floor(entity.y + camera.y) + Math.sin(entity.rotation) * entity.size * 0.6);\n    canvas.stroke(); // --------\n    // Paint actor sprite\n    // --------\n\n    if (entity.animationSpritesheet) {\n      var SPRITE_SIZE = 48;\n      var SPRITE_OFFSET_X = 0;\n      var SPRITE_OFFSET_Y = -8;\n      var srcSizeX = SPRITE_SIZE;\n      var srcSizeY = SPRITE_SIZE;\n      var srcX = 0;\n      var srcY = 0;\n\n      switch (entity.direction) {\n        case _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"DIRECTIONS\"].SOUTH:\n          srcX = SPRITE_SIZE * 0;\n          break;\n\n        case _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"DIRECTIONS\"].NORTH:\n          srcX = SPRITE_SIZE * 1;\n          break;\n\n        case _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"DIRECTIONS\"].EAST:\n          srcX = SPRITE_SIZE * 2;\n          break;\n\n        case _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"DIRECTIONS\"].WEST:\n          srcX = SPRITE_SIZE * 3;\n          break;\n      }\n\n      switch (entity.animationName) {\n        case 'move-1':\n          srcY = SPRITE_SIZE * 1;\n          break;\n\n        case 'move-2':\n          srcY = SPRITE_SIZE * 2;\n          break;\n\n        case 'move-3':\n          srcY = SPRITE_SIZE * 3;\n          break;\n\n        case 'attack-windup':\n          srcY = SPRITE_SIZE * 4;\n          break;\n\n        case 'attack-active':\n          srcY = SPRITE_SIZE * 5;\n          break;\n\n        case 'attack-winddown':\n          srcY = SPRITE_SIZE * 5;\n          break;\n\n        case 'dash':\n          srcY = SPRITE_SIZE * 1;\n          break;\n      }\n\n      var tgtSizeX = SPRITE_SIZE;\n      var tgtSizeY = SPRITE_SIZE;\n      var tgtX = Math.floor(entity.x + camera.x) - srcSizeX / 2 + SPRITE_OFFSET_X;\n      var tgtY = Math.floor(entity.y + camera.y) - srcSizeY / 2 + SPRITE_OFFSET_Y;\n      canvas.drawImage(entity.animationSpritesheet.img, srcX, srcY, srcSizeX, srcSizeY, tgtX, tgtY, tgtSizeX, tgtSizeY);\n    } // --------\n    // Paint UI entitys\n    // --------\n\n\n    var healthOffsetY = 7;\n    var healthRatio = entity.attr.maxHealth > 0 ? (entity.attr.health || 0) / entity.attr.maxHealth : 0;\n    canvas.strokeStyle = 'rgba(0, 0, 0)';\n    canvas.lineWidth = 4;\n    canvas.beginPath();\n    canvas.moveTo(Math.floor(entity.x + camera.x) - entity.size / 3, Math.floor(entity.y + camera.y) + entity.size / 2 + healthOffsetY);\n    canvas.lineTo(Math.floor(entity.x + camera.x) + entity.size / 3, Math.floor(entity.y + camera.y) + entity.size / 2 + healthOffsetY);\n    canvas.stroke();\n    canvas.strokeStyle = 'rgba(255, 0, 0)';\n    canvas.lineWidth = 2;\n    canvas.beginPath();\n    canvas.moveTo(Math.floor(entity.x + camera.x) - entity.size / 3 * healthRatio, Math.floor(entity.y + camera.y) + entity.size / 2 + healthOffsetY);\n    canvas.lineTo(Math.floor(entity.x + camera.x) + entity.size / 3 * healthRatio, Math.floor(entity.y + camera.y) + entity.size / 2 + healthOffsetY);\n    canvas.stroke();\n    healthOffsetY = 4;\n    canvas.font = '8px Arial';\n    canvas.fillStyle = 'rgba(204, 68, 68)';\n    canvas.textBaseline = 'hanging';\n    canvas.textAlign = 'right';\n    canvas.fillText('❤️', Math.floor(entity.x + camera.x) - entity.size / 3, Math.floor(entity.y + camera.y) + entity.size / 2 + healthOffsetY);\n    canvas.textAlign = 'left';\n    canvas.fillText(Math.floor(entity.attr.health), Math.floor(entity.x + camera.x) + entity.size / 3, Math.floor(entity.y + camera.y) + entity.size / 2 + healthOffsetY); // --------\n  },\n  PARTICLE: function PARTICLE(app, entity, canvas, camera) {\n    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    var layer = options.layer || '';\n    if (!canvas || !camera) return; // Simple shadow\n\n    canvas.fillStyle = 'rgba(238, 238, 204, 0.5)';\n    canvas.beginPath();\n    canvas.arc(entity.x + camera.x, entity.y + camera.y, entity.size / 2, 0, 2 * Math.PI);\n    canvas.fill();\n  }\n};\n\n//# sourceURL=webpack:///./src/avo/animations/index.js?");

/***/ }),

/***/ "./src/avo/avo-adventure.js":
/*!**********************************!*\
  !*** ./src/avo/avo-adventure.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _avo_action_mode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/action-mode */ \"./src/avo/action-mode/index.js\");\n/* harmony import */ var _avo_interaction_mode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/interaction-mode */ \"./src/avo/interaction-mode/index.js\");\n/* harmony import */ var _avo_story__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @avo/story */ \"./src/avo/story.js\");\n/* harmony import */ var _avo_map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @avo/map */ \"./src/avo/map/index.js\");\n/* harmony import */ var _avo_misc_constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @avo/misc/constants */ \"./src/avo/misc/constants.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n\n\nvar AvoAdventure = /*#__PURE__*/function () {\n  function AvoAdventure(story) {\n    _classCallCheck(this, AvoAdventure);\n\n    this.mode = _avo_misc_constants__WEBPACK_IMPORTED_MODULE_4__[\"MODES\"].INITIALISING;\n    this.nextMode = undefined; // When asked to change modes, it's queued instead of instant.\n\n    this.actors = [];\n    this.particles = [];\n    this.assets = {};\n    this.data = {};\n    this.map = new _avo_map__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this);\n    this.camera = {\n      x: 0,\n      y: 0,\n      targetActor: null // Sets an Actor to follow. If null, camera is static.\n\n    };\n    this.playerActor = null;\n    this.actionMode = new _avo_action_mode__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this);\n    this.interactionMode = new _avo_interaction_mode__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this); // Initialise the story\n\n    this.story = story || new _avo_story__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this);\n    this.prevTime = null;\n    this.nextFrame = window.requestAnimationFrame(this.main.bind(this));\n  }\n\n  _createClass(AvoAdventure, [{\n    key: \"changeMode\",\n    value: function changeMode(nextMode) {\n      this.nextMode = nextMode;\n    }\n  }, {\n    key: \"_changeMode\",\n    value: function _changeMode() {\n      if (this.mode === _avo_misc_constants__WEBPACK_IMPORTED_MODULE_4__[\"MODES\"].ACTION) this.actionMode.unload();\n      if (this.mode === _avo_misc_constants__WEBPACK_IMPORTED_MODULE_4__[\"MODES\"].INTERACTION) this.interactionMode.unload();\n      if (this.nextMode === _avo_misc_constants__WEBPACK_IMPORTED_MODULE_4__[\"MODES\"].ACTION) this.actionMode.load();\n      if (this.nextMode === _avo_misc_constants__WEBPACK_IMPORTED_MODULE_4__[\"MODES\"].INTERACTION) this.interactionMode.load();\n      this.mode = this.nextMode;\n      this.nextMode = undefined;\n    }\n    /*  Each main step is a 'frame' in the game\r\n     */\n\n  }, {\n    key: \"main\",\n    value: function main(time) {\n      var timeStep = this.prevTime ? time - this.prevTime : time;\n      this.prevTime = time;\n      if (this.mode === _avo_misc_constants__WEBPACK_IMPORTED_MODULE_4__[\"MODES\"].INITIALISING) this.startStoryIfReady();\n      if (this.nextMode) this._changeMode(); // Run game logic and update game visuals\n      // Note: gameplay and visual frames are tied.\n\n      this.play(timeStep);\n      this.paint();\n      this.cleanUp();\n      this.nextFrame = window.requestAnimationFrame(this.main.bind(this));\n    }\n    /*  Run game logic\r\n     */\n\n  }, {\n    key: \"play\",\n    value: function play(timeStep) {\n      var story = this.story;\n\n      if (!story.skipPlay()) {\n        if (this.mode === _avo_misc_constants__WEBPACK_IMPORTED_MODULE_4__[\"MODES\"].ACTION) this.actionMode.play(timeStep);\n      }\n\n      story.customPlay(timeStep);\n    }\n    /*  Update game visuals\r\n     */\n\n  }, {\n    key: \"paint\",\n    value: function paint() {\n      var story = this.story;\n\n      if (!story.skipPaint()) {\n        if (this.mode === _avo_misc_constants__WEBPACK_IMPORTED_MODULE_4__[\"MODES\"].ACTION) this.actionMode.paint();\n      }\n\n      story.customPaint();\n    }\n    /*  Remove expired entities\r\n     */\n\n  }, {\n    key: \"cleanUp\",\n    value: function cleanUp() {\n      this.actors = this.actors.filter(function (actor) {\n        return !actor._expired;\n      });\n      this.particles = this.particles.filter(function (particle) {\n        return !particle._expired;\n      });\n    }\n    /*  Check if Story is ready to start\r\n     */\n\n  }, {\n    key: \"startStoryIfReady\",\n    value: function startStoryIfReady() {\n      var _this = this;\n\n      if (this.mode !== _avo_misc_constants__WEBPACK_IMPORTED_MODULE_4__[\"MODES\"].INITIALISING) return; // Assets Check\n\n      var allAssetsLoaded = true;\n      Object.keys(this.assets).forEach(function (id) {\n        var asset = _this.assets[id];\n        allAssetsLoaded = allAssetsLoaded && asset.loaded;\n      });\n\n      if (allAssetsLoaded) {\n        this.story.start(this);\n      }\n    }\n  }]);\n\n  return AvoAdventure;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (AvoAdventure);\n\n//# sourceURL=webpack:///./src/avo/avo-adventure.js?");

/***/ }),

/***/ "./src/avo/entities/actor.js":
/*!***********************************!*\
  !*** ./src/avo/entities/actor.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/misc/constants */ \"./src/avo/misc/constants.js\");\n/* harmony import */ var _avo_actions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/actions */ \"./src/avo/actions/index.js\");\n/* harmony import */ var _avo_reactions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @avo/reactions */ \"./src/avo/reactions/index.js\");\n/* harmony import */ var _avo_animations__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @avo/animations */ \"./src/avo/animations/index.js\");\n/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./entity */ \"./src/avo/entities/entity.js\");\n/* harmony import */ var _particle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./particle */ \"./src/avo/entities/particle.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\n\n\n\nvar Actor = /*#__PURE__*/function (_Entity) {\n  _inherits(Actor, _Entity);\n\n  var _super = _createSuper(Actor);\n\n  function Actor(app) {\n    var _this;\n\n    var initialValues = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Actor);\n\n    _this = _super.call(this, app);\n    _this.shape = _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"SHAPES\"].CIRCLE;\n    _this.solid = true;\n    _this.movable = true;\n    _this.moveAcceleration = 60;\n    _this.moveDeceleration = 60;\n    _this.moveMaxSpeed = 4;\n    _this.attr = {\n      health: 100,\n      // TEMP\n      maxHealth: 100 // TEMP\n\n    };\n    _this.intent = undefined;\n    _this.actionName = 'idle';\n    _this.actionAttr = {};\n    _this.actionCounter = 0;\n    _this.actions = {\n      'idle': _avo_actions__WEBPACK_IMPORTED_MODULE_1__[\"STANDARD_ACTIONS\"].IDLE,\n      'move': _avo_actions__WEBPACK_IMPORTED_MODULE_1__[\"STANDARD_ACTIONS\"].MOVE,\n      'attack': _avo_actions__WEBPACK_IMPORTED_MODULE_1__[\"STANDARD_ACTIONS\"].ATTACK,\n      'dash': _avo_actions__WEBPACK_IMPORTED_MODULE_1__[\"STANDARD_ACTIONS\"].DASH\n    };\n    _this.reactions = {\n      'damage': _avo_reactions__WEBPACK_IMPORTED_MODULE_2__[\"STANDARD_REACTIONS\"].DAMAGE,\n      'push': _avo_reactions__WEBPACK_IMPORTED_MODULE_2__[\"STANDARD_REACTIONS\"].PUSH\n    };\n    _this.animationScript = _avo_animations__WEBPACK_IMPORTED_MODULE_3__[\"STANDARD_ANIMATIONS\"].ACTOR; // Set initial values\n\n    Object.assign(_assertThisInitialized(_this), initialValues);\n    return _this;\n  }\n\n  _createClass(Actor, [{\n    key: \"play\",\n    value: function play(timeStep) {\n      _get(_getPrototypeOf(Actor.prototype), \"play\", this).call(this, timeStep);\n\n      var app = this._app;\n      this.processIntent();\n      this.processActions(timeStep);\n\n      if (this.attr.health <= 0) {\n        this._expired = true;\n      }\n\n      if (this.attr.health < this.attr.maxHealth) {\n        this.attr.health += 0.05;\n      } // Upkeep: deceleration\n\n\n      if (this.actionName !== 'move') {\n        var moveDeceleration = this.moveDeceleration * timeStep / 1000 || 0;\n        var curRotation = Math.atan2(this.moveY, this.moveX);\n        var curMoveSpeed = Math.sqrt(this.moveX * this.moveX + this.moveY * this.moveY);\n        var newMoveSpeed = Math.max(0, curMoveSpeed - moveDeceleration);\n        this.moveX = newMoveSpeed * Math.cos(curRotation);\n        this.moveY = newMoveSpeed * Math.sin(curRotation);\n      }\n    }\n  }, {\n    key: \"processIntent\",\n    value: function processIntent() {\n      // Translate intent into action.\n      var action = this.actions[this.actionName];\n\n      if (!action) {\n        // Sanity check: if the Actor isn't doing anything, go idle.\n        this.goIdle(); // This is just a failsafe - the actor should ALWAYS have an action, even if it's the IDLE action.\n      } else if (!this.intent) {\n        // If the Actor has no intent (e.g. player has no key input)...\n        // ...cancel any currently cancellable actions.\n        // (Obviously, ignore this if the \n        if (action.type === _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION_TYPES\"].CONTINUOUS) this.goIdle();\n      } else {\n        // Actor intends to perform a new action.\n        // First, can the current action be overwritten by a new action?\n        if (action.type === _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION_TYPES\"].IDLE || action.type === _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION_TYPES\"].CONTINUOUS) {\n          // Second, check if the new action is different from the old one. \n          // Reset the actionCounter if that's the case.\n          if (this.actionName !== this.intent.name) {\n            this.actionCounter = 0;\n          } // Finally, convert the intent into the new action.\n\n\n          this.actionName = this.intent.name;\n          this.actionAttr = this.intent.attr ? _objectSpread({}, this.intent.attr) : {};\n        }\n      }\n    }\n  }, {\n    key: \"goIdle\",\n    value: function goIdle() {\n      this.actionName = 'idle';\n      this.actionCounter = 0;\n      this.actionAttr = {};\n    }\n  }, {\n    key: \"processActions\",\n    value: function processActions(timeStep) {\n      var app = this._app;\n      var action = this.actions[this.actionName];\n      if (!action) return;\n      var progress = action.duration > 0 ? this.actionCounter / action.duration : 0;\n      action.script({\n        app: app,\n        entity: this,\n        action: action,\n        actionAttr: this.actionAttr,\n        progress: progress,\n        timeStep: timeStep\n      });\n      this.actionCounter += timeStep;\n\n      if (this.actionCounter >= action.duration) {\n        // Is the action over?\n        this.actionCounter = 0; // If it's over (and doesn't loop), revert to default.\n\n        if (action.type === _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION_TYPES\"].STANDARD || action.type === _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION_TYPES\"].SPECIAL_ONCE) {\n          this.goIdle();\n        }\n      }\n    }\n  }]);\n\n  return Actor;\n}(_entity__WEBPACK_IMPORTED_MODULE_4__[\"default\"]);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Actor);\n\n//# sourceURL=webpack:///./src/avo/entities/actor.js?");

/***/ }),

/***/ "./src/avo/entities/entity.js":
/*!************************************!*\
  !*** ./src/avo/entities/entity.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/misc/constants */ \"./src/avo/misc/constants.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar Entity = /*#__PURE__*/function () {\n  function Entity(app) {\n    _classCallCheck(this, Entity);\n\n    this._app = app; // Expired entities are removed at the end of the cycle.\n\n    this._expired = false;\n    this.attr = {};\n    this.x = 0;\n    this.y = 0;\n    this.size = 32; // TODO: this.z = 1;\n\n    this._rotation = _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"ROTATIONS\"].SOUTH; // Rotation in radians\n    // Movement: self locomotion and external (pushed) movement.\n\n    this.moveX = 0;\n    this.moveY = 0;\n    this.pushX = 0;\n    this.pushY = 0;\n    this.shape = _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"SHAPES\"].NONE;\n    this.shapePolygonPath = null; // Only applicable if shape === SHAPES.POLYGON\n\n    this.solid = false;\n    this.movable = false;\n    this.animationName = 'idle';\n    this.animationSpritesheet = null;\n\n    this.animationScript = function (app, entity, canvas) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    };\n\n    this.effects = []; // Effects applied to the Actor/Particle/etc.\n\n    this.reactions = {}; // Reaction scripts; tells what the Actor/Particle/etc should do when they receive an Effect.\n    // Custom script to play on every frame.\n\n    this.alwaysScript = function (_ref) {\n      var app = _ref.app,\n          entitiy = _ref.entitiy,\n          timeStep = _ref.timeStep;\n    }; // Custom script to run on every frame of collision with another entity.\n\n\n    this.collisionScript = function (_ref2) {\n      var app = _ref2.app,\n          entitiy = _ref2.entitiy,\n          target = _ref2.target,\n          collisionCorrection = _ref2.collisionCorrection;\n    };\n  }\n\n  _createClass(Entity, [{\n    key: \"onCollision\",\n    value: function onCollision(target, collisionCorrection) {\n      this.collisionScript && this.collisionScript({\n        app: this._app,\n        entitiy: this,\n        target: target,\n        collisionCorrection: collisionCorrection\n      });\n    }\n  }, {\n    key: \"paint\",\n    value: function paint(canvas, camera) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      // TODO: see https://www.html5rocks.com/en/tutorials/canvas/hidpi/ about using window.devicePixelRatio to fix blurriness on a High DPI canvas\n      this.animationScript && this.animationScript(this._app, this, canvas, camera, options);\n    }\n  }, {\n    key: \"play\",\n    value: function play(timeStep) {\n      var app = this._app;\n      this.alwaysScript && this.alwaysScript({\n        app: app,\n        entity: this,\n        timeStep: timeStep\n      });\n      this.processEffects(timeStep);\n    }\n  }, {\n    key: \"processEffects\",\n    value: function processEffects(timeStep) {\n      var _this = this;\n\n      var app = this._app;\n      this.effects.forEach(function (effect) {\n        var reaction = _this.reactions[effect.name] || {}; // For each active Effect, run a reaction.\n\n        if (effect.duration > 0) {\n          reaction.always && reaction.always({\n            app: app,\n            entity: _this,\n            effect: effect,\n            timeStep: timeStep\n          });\n        } // Effects should decay (unless duration === Infinity, of course) \n\n\n        effect.duration -= timeStep; // Prepare to end any old effects.\n\n        if (effect.duration <= 0) reaction.onRemove && reaction.onRemove({\n          app: app,\n          entity: _this,\n          effect: effect\n        });\n      }); // Remove old effects\n\n      this.effects = this.effects.filter(function (effect) {\n        return effect.duration > 0;\n      });\n    }\n  }, {\n    key: \"left\",\n    get: function get() {\n      return this.x - this.size / 2;\n    },\n    set: function set(val) {\n      this.x = val + this.size / 2;\n    }\n  }, {\n    key: \"right\",\n    get: function get() {\n      return this.x + this.size / 2;\n    },\n    set: function set(val) {\n      this.x = val - this.size / 2;\n    }\n  }, {\n    key: \"top\",\n    get: function get() {\n      return this.y - this.size / 2;\n    },\n    set: function set(val) {\n      this.y = val + this.size / 2;\n    }\n  }, {\n    key: \"bottom\",\n    get: function get() {\n      return this.y + this.size / 2;\n    },\n    set: function set(val) {\n      this.y = val - this.size / 2;\n    }\n  }, {\n    key: \"radius\",\n    get: function get() {\n      return this.size / 2;\n    },\n    set: function set(val) {\n      this.size = val * 2;\n    }\n  }, {\n    key: \"rotation\",\n    get: function get() {\n      return this._rotation;\n    },\n    set: function set(val) {\n      this._rotation = val;\n\n      while (this._rotation > Math.PI) {\n        this._rotation -= Math.PI * 2;\n      }\n\n      while (this._rotation <= -Math.PI) {\n        this._rotation += Math.PI * 2;\n      }\n    }\n  }, {\n    key: \"direction\",\n    get: function get() {\n      //Get cardinal direction\n      //Favour East and West when rotation is exactly SW, NW, SE or NE.\n      if (this._rotation <= Math.PI * 0.25 && this._rotation >= Math.PI * -0.25) {\n        return _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"DIRECTIONS\"].EAST;\n      } else if (this._rotation > Math.PI * 0.25 && this._rotation < Math.PI * 0.75) {\n        return _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"DIRECTIONS\"].SOUTH;\n      } else if (this._rotation < Math.PI * -0.25 && this._rotation > Math.PI * -0.75) {\n        return _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"DIRECTIONS\"].NORTH;\n      } else {\n        return _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"DIRECTIONS\"].WEST;\n      }\n    },\n    set: function set(val) {\n      switch (val) {\n        case _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"DIRECTIONS\"].EAST:\n          this._rotation = _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"ROTATIONS\"].EAST;\n          break;\n\n        case _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"DIRECTIONS\"].SOUTH:\n          this._rotation = _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"ROTATIONS\"].SOUTH;\n          break;\n\n        case _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"DIRECTIONS\"].WEST:\n          this._rotation = _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"ROTATIONS\"].WEST;\n          break;\n\n        case _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"DIRECTIONS\"].NORTH:\n          this._rotation = _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"ROTATIONS\"].NORTH;\n          break;\n      }\n    }\n  }, {\n    key: \"vertices\",\n    get: function get() {\n      var _this2 = this;\n\n      var v = [];\n\n      if (this.shape === _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"SHAPES\"].SQUARE) {\n        v.push({\n          x: this.left,\n          y: this.top\n        });\n        v.push({\n          x: this.right,\n          y: this.top\n        });\n        v.push({\n          x: this.right,\n          y: this.bottom\n        });\n        v.push({\n          x: this.left,\n          y: this.bottom\n        });\n      } else if (this.shape === _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"SHAPES\"].CIRCLE) {\n        //Approximation\n        CIRCLE_TO_POLYGON_APPROXIMATOR.map(function (approximator) {\n          v.push({\n            x: _this2.x + _this2.radius * approximator.cosAngle,\n            y: _this2.y + _this2.radius * approximator.sinAngle\n          });\n        });\n      } else if (this.shape === _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"SHAPES\"].POLYGON) {\n        if (!this.shapePolygonPath) return [];\n\n        for (var i = 0; i < this.shapePolygonPath.length; i += 2) {\n          v.push({\n            x: this.x + this.shapePolygonPath[i],\n            y: this.y + this.shapePolygonPath[i + 1]\n          });\n        }\n      }\n\n      return v;\n    }\n  }]);\n\n  return Entity;\n}();\n\nvar CIRCLE_TO_POLYGON_APPROXIMATOR = [_avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"ROTATIONS\"].EAST, _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"ROTATIONS\"].SOUTHEAST, _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"ROTATIONS\"].SOUTH, _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"ROTATIONS\"].SOUTHWEST, _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"ROTATIONS\"].WEST, _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"ROTATIONS\"].NORTHWEST, _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"ROTATIONS\"].NORTH, _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"ROTATIONS\"].NORTHEAST].map(function (angle) {\n  return {\n    cosAngle: Math.cos(angle),\n    sinAngle: Math.sin(angle)\n  };\n});\n/* harmony default export */ __webpack_exports__[\"default\"] = (Entity);\n\n//# sourceURL=webpack:///./src/avo/entities/entity.js?");

/***/ }),

/***/ "./src/avo/entities/particle.js":
/*!**************************************!*\
  !*** ./src/avo/entities/particle.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/misc/constants */ \"./src/avo/misc/constants.js\");\n/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./entity */ \"./src/avo/entities/entity.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\nvar Particle = /*#__PURE__*/function (_Entity) {\n  _inherits(Particle, _Entity);\n\n  var _super = _createSuper(Particle);\n\n  function Particle(app, initialValues) {\n    var _this;\n\n    _classCallCheck(this, Particle);\n\n    _this = _super.call(this, app);\n    _this.shape = _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"SHAPES\"].CIRCLE; // Custom script to run when a Particle hits a valid target.\n    // Different from collisionScript() in two ways:\n    // - Particles are more picky about what they consider valid targets.\n    // - Payloads can only hit targets once every few frames, not on every\n    //   frame of collision.\n\n    _this.payloadScript = function (_ref) {\n      var app = _ref.app,\n          entity = _ref.entity,\n          target = _ref.target;\n    }; // Particles can have a limited duration.\n\n\n    _this.duration = Infinity; // When applying effects on collision, Particles can ignore their source\n    // (the Actor that created it), if any.\n    // (e.g. sword swings shouldn't hit their wielder. Nobody's that clumsy.)\n\n    _this.source = undefined;\n    _this.ignoreSource = false; // When applying effects on collision, Particles shouldn't hit the same\n    // targets perpetually every single frame.\n\n    _this._recentCollisionTargets = []; // Set initial values\n\n    Object.assign(_assertThisInitialized(_this), initialValues);\n    return _this;\n  }\n\n  _createClass(Particle, [{\n    key: \"play\",\n    value: function play(timeStep) {\n      _get(_getPrototypeOf(Particle.prototype), \"play\", this).call(this, timeStep);\n\n      var app = this._app; // Perform upkeep on the list of recent targets:\n      // Tick down the recent target's duration, then remove any that has 0 duration.\n\n      this._recentCollisionTargets = this._recentCollisionTargets.filter(function (item) {\n        item.duration -= timeStep;\n        return item.duration > 0;\n      }); // Tick down the duration and remove if the timer runs out.\n      // Note that if duration === Infinity, the Particle is permanent.\n\n      this.duration -= timeStep;\n      if (this.duration < 0) this._expired = true;\n    }\n  }, {\n    key: \"onCollision\",\n    value: function onCollision(target, collisionCorrection) {\n      _get(_getPrototypeOf(Particle.prototype), \"onCollision\", this).call(this, target, collisionCorrection);\n\n      var app = this._app;\n      var targetIsValid = !!target // Is there a target?\n      && !(this.ignoreSource && this.source === target) // If the target is the source of the Particle, ignore it?\n      && !this._recentCollisionTargets.find(function (t) {\n        return t.target === target;\n      });\n\n      if (targetIsValid) {\n        this.payloadScript && this.payloadScript({\n          app: app,\n          entity: this,\n          target: target\n        }); // Add to the list of recent targets, so targets aren't hit back to back to back.\n\n        this._recentCollisionTargets.push({\n          target: target,\n          duration: _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"TIME_BETWEEN_SUCCESSIVE_PAYLOADS\"]\n        });\n      }\n    }\n  }, {\n    key: \"applyEffect\",\n    value: function applyEffect(effect, target) {\n      if (!effect || !target) return;\n      var shouldApply = !!target.reactions[effect.name]; // Does the target have a script to react to this effect?\n      // TODO: check on effects stacking.\n      // const existingEffect = target.effects.find(eff => eff.name === effect.name);\n\n      if (shouldApply) {\n        // Prepare to add new effect\n        var reaction = target.reactions[effect.name] || {};\n        reaction.onAdd && reaction.onAdd(app, target, effect);\n        target.effects.push(effect);\n      }\n    }\n  }]);\n\n  return Particle;\n}(_entity__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Particle);\n\n//# sourceURL=webpack:///./src/avo/entities/particle.js?");

/***/ }),

/***/ "./src/avo/index.js":
/*!**************************!*\
  !*** ./src/avo/index.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _avo_adventure__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./avo-adventure */ \"./src/avo/avo-adventure.js\");\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (_avo_adventure__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack:///./src/avo/index.js?");

/***/ }),

/***/ "./src/avo/interaction-mode/index.js":
/*!*******************************************!*\
  !*** ./src/avo/interaction-mode/index.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _interaction_mode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interaction-mode */ \"./src/avo/interaction-mode/interaction-mode.js\");\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (_interaction_mode__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack:///./src/avo/interaction-mode/index.js?");

/***/ }),

/***/ "./src/avo/interaction-mode/interaction-mode.js":
/*!******************************************************!*\
  !*** ./src/avo/interaction-mode/interaction-mode.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _avo_interactions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/interactions */ \"./src/avo/interactions/index.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar InteractionMode = /*#__PURE__*/function () {\n  function InteractionMode(app) {\n    _classCallCheck(this, InteractionMode);\n\n    this._app = app;\n    this.html = document.getElementById('interaction-mode');\n    this.interaction = new _avo_interactions__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this._app);\n  }\n\n  _createClass(InteractionMode, [{\n    key: \"load\",\n    value: function load() {\n      this.html.className = 'active';\n      this.interaction && this.interaction.load();\n      this.focus();\n    }\n  }, {\n    key: \"unload\",\n    value: function unload() {\n      this.html.className = '';\n    }\n  }, {\n    key: \"focus\",\n    value: function focus() {\n      this.interaction && this.interaction.focus();\n    }\n  }, {\n    key: \"add\",\n    value: function add(node) {\n      this.html.appendChild(node);\n    }\n  }, {\n    key: \"empty\",\n    value: function empty() {\n      while (this.html.firstChild) {\n        this.html.removeChild(this.html.firstChild);\n      }\n    }\n  }]);\n\n  return InteractionMode;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (InteractionMode);\n\n//# sourceURL=webpack:///./src/avo/interaction-mode/interaction-mode.js?");

/***/ }),

/***/ "./src/avo/interactions/index.js":
/*!***************************************!*\
  !*** ./src/avo/interactions/index.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/misc/constants */ \"./src/avo/misc/constants.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar Interaction = /*#__PURE__*/function () {\n  function Interaction(app) {\n    _classCallCheck(this, Interaction);\n\n    this._app = app;\n  }\n\n  _createClass(Interaction, [{\n    key: \"load\",\n    value: function load() {\n      var _this = this;\n\n      var container = this._app.interactionMode;\n      container.empty();\n      var panel = document.createElement('div');\n      panel.className = 'simple interaction';\n      container.add(panel);\n      var closeButton = document.createElement('button');\n      closeButton.textContent = 'CLOSE';\n\n      closeButton.onclick = function () {\n        _this._app.changeMode(_avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"MODES\"].ACTION);\n      };\n\n      panel.appendChild(closeButton);\n      var simpleText = document.createElement('div');\n      simpleText.textContent = 'MAIN MENU';\n      simpleText.style.padding = '1em';\n      simpleText.style.background = '#fff';\n      panel.appendChild(simpleText);\n    }\n  }, {\n    key: \"unload\",\n    value: function unload() {\n      var container = this._app.interactionMode;\n      this.container.empty();\n    }\n  }, {\n    key: \"focus\",\n    value: function focus() {\n      var container = this._app.interactionMode;\n      var buttons = container.html.getElementsByTagName('button');\n\n      if (buttons[0]) {\n        buttons[0].focus();\n      }\n    }\n  }]);\n\n  return Interaction;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Interaction);\n\n//# sourceURL=webpack:///./src/avo/interactions/index.js?");

/***/ }),

/***/ "./src/avo/map/index.js":
/*!******************************!*\
  !*** ./src/avo/map/index.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map */ \"./src/avo/map/map.js\");\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (_map__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack:///./src/avo/map/index.js?");

/***/ }),

/***/ "./src/avo/map/map.js":
/*!****************************!*\
  !*** ./src/avo/map/map.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar DEFAULT_TILE_TYPE = {\n  floor: false,\n  wall: false,\n  colour: '#fff'\n};\n\nvar Map = /*#__PURE__*/function () {\n  function Map(app, initialValues) {\n    _classCallCheck(this, Map);\n\n    this._app = app;\n    this.width = 16;\n    this.height = 16;\n    this.tiles = '  ############  ' + ' ##          ## ' + '##            ##' + '#              #' + '#    ##  ##    #' + '#   ##    ##   #' + '#   #      #   #' + '#      ##      #' + '#      ##      #' + '#   #      #   #' + '# # ##    ## # #' + '##   ##  ##   ##' + '#              #' + '##   # ## #   ##' + ' ##          ## ' + '  ############  ';\n    this.tileSize = 32;\n    this.tileTypes = {\n      ' ': {\n        floor: true,\n        wall: false,\n        colour: '#efd'\n      },\n      '#': {\n        floor: true,\n        wall: true,\n        colour: '#486'\n      }\n    }; // Set initial values\n\n    Object.assign(this, initialValues);\n  }\n\n  _createClass(Map, [{\n    key: \"paint\",\n    value: function paint(canvas, camera) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var app = this._app;\n      var size = this.tileSize;\n      if (!canvas || !camera) return;\n\n      for (var row = 0; row < this.height; row++) {\n        for (var col = 0; col < this.height; col++) {\n          var tile = this.getTile(col, row);\n          canvas.fillStyle = tile && tile.colour || '#fff';\n          canvas.fillRect(col * size + Math.floor(camera.x), row * size + Math.floor(camera.y), size, size);\n        }\n      }\n    }\n  }, {\n    key: \"checkCollision\",\n    value: function checkCollision(entity) {\n      if (!entity || !entity.solid) return; // First check if there are any collisions in the cardinal directions.\n\n      var collisionCorrection = this.checkCollision_cardinals(entity); // If not, check for collisions in the diagonal directions.\n\n      if (collisionCorrection.x === 0 && collisionCorrection.y === 0) {\n        collisionCorrection = this.checkCollision_diagonals(entity);\n      }\n\n      return {\n        x: entity.x + collisionCorrection.x,\n        y: entity.y + collisionCorrection.y\n      };\n    }\n  }, {\n    key: \"checkCollision_cardinals\",\n    value: function checkCollision_cardinals(entity) {\n      var size = this.tileSize;\n      var leftCol = Math.floor(entity.left / size);\n      var midCol = Math.floor(entity.x / size);\n      var rightCol = Math.floor(entity.right / size);\n      var topRow = Math.floor(entity.top / size);\n      var midRow = Math.floor(entity.y / size);\n      var bottomRow = Math.floor(entity.bottom / size);\n      var tileL = this.getTile(leftCol, midRow);\n      var tileR = this.getTile(rightCol, midRow);\n      var tileT = this.getTile(midCol, topRow);\n      var tileB = this.getTile(midCol, bottomRow); // Determine which tiles are blocking the entity, and in which direction\n      // the correction needs to be done.\n\n      var correctionDirectionX = 0;\n      var correctionDirectionY = 0;\n\n      if (tileL.wall) {\n        correctionDirectionX++;\n      }\n\n      if (tileR.wall) {\n        correctionDirectionX--;\n      }\n\n      if (tileT.wall) {\n        correctionDirectionY++;\n      }\n\n      if (tileB.wall) {\n        correctionDirectionY--;\n      } // Determine how far the correction needs to be made.\n      // (i.e. determine how 'deep' the entity pushed into the blocking tile.)\n\n\n      var correctionX = 0;\n      var correctionY = 0;\n\n      if (correctionDirectionX > 0) {\n        var tileEdgeX = leftCol * size + size;\n        correctionX = tileEdgeX - entity.left;\n      } else if (correctionDirectionX < 0) {\n        var _tileEdgeX = rightCol * size;\n\n        correctionX = _tileEdgeX - entity.right;\n      }\n\n      if (correctionDirectionY > 0) {\n        var tileEdgeY = topRow * size + size;\n        correctionY = tileEdgeY - entity.top;\n      } else if (correctionDirectionY < 0) {\n        var _tileEdgeY = bottomRow * size;\n\n        correctionY = _tileEdgeY - entity.bottom;\n      }\n\n      return {\n        x: correctionX,\n        y: correctionY\n      }; // Note: previously, before we had checkCollision_diagonals(), we had a\n      // 'gradual correction' code that pushed the entity out of the wall bit\n      // by bit to avoid a sudden repositioning of the entity.\n      // Weakness: if the entity's movement speed exceeds the GRADUAL_CORRECTION\n      // value, the entity can just jog through the wall. If the\n      // GRADUAL_CORRECTION was too high, we'd just repeat the sudden\n      // repositioning problem.\n      //\n      // const GRADUAL_CORRECTION = 8;\n      // if (correctionDirectionX > 0) {\n      //    const tileEdgeX = leftCol * size + size;\n      //    const penetratingX = entity.left - tileEdgeX;\n      //    correctionX = Math.min(-penetratingX, GRADUAL_CORRECTION);\n      // }\n    }\n  }, {\n    key: \"checkCollision_diagonals\",\n    value: function checkCollision_diagonals(entity) {\n      var size = this.tileSize;\n      var leftCol = Math.floor(entity.left / size);\n      var rightCol = Math.floor(entity.right / size);\n      var topRow = Math.floor(entity.top / size);\n      var bottomRow = Math.floor(entity.bottom / size);\n      var tileLT = this.getTile(leftCol, topRow);\n      var tileRT = this.getTile(rightCol, topRow);\n      var tileLB = this.getTile(leftCol, bottomRow);\n      var tileRB = this.getTile(rightCol, bottomRow); // Determine which tiles are blocking the entity, and in which direction\n      // the correction needs to be done.\n\n      var correctionDirectionX = 0;\n      var correctionDirectionY = 0;\n\n      if (tileLT.wall) {\n        correctionDirectionX++;\n        correctionDirectionY++;\n      }\n\n      if (tileRT.wall) {\n        correctionDirectionX--;\n        correctionDirectionY++;\n      }\n\n      if (tileLB.wall) {\n        correctionDirectionX++;\n        correctionDirectionY--;\n      }\n\n      if (tileRB.wall) {\n        correctionDirectionX--;\n        correctionDirectionY--;\n      }\n\n      var correctionX = 0;\n      var correctionY = 0;\n\n      if (correctionDirectionX !== 0 && correctionDirectionY !== 0) {\n        var cornerX = 0;\n        var cornerY = 0;\n        if (correctionDirectionX > 0) cornerX = leftCol * size + size;\n        if (correctionDirectionX < 0) cornerX = rightCol * size;\n        if (correctionDirectionY > 0) cornerY = topRow * size + size;\n        if (correctionDirectionY < 0) cornerY = bottomRow * size; // Assumes entity is a circle.\n\n        var distX = entity.x - cornerX;\n        var distY = entity.y - cornerY;\n        var dist = Math.sqrt(distX * distX + distY * distY); // If entity's radius is too close to the corner, push the entity away. \n\n        if (dist < entity.radius) {\n          var angle = Math.atan2(distY, distX);\n          correctionX = (entity.radius - dist) * Math.cos(angle);\n          correctionY = (entity.radius - dist) * Math.sin(angle);\n        }\n      }\n\n      return {\n        x: correctionX,\n        y: correctionY\n      };\n    }\n  }, {\n    key: \"getTile\",\n    value: function getTile(col, row) {\n      var index = col >= 0 && col < this.width && row >= 0 && row < this.height ? row * this.width + col : undefined;\n      var size = this.tileSize;\n      var tileValue = this.tiles[index] || '';\n      var tileType = this.tileTypes[tileValue] || DEFAULT_TILE_TYPE;\n      return _objectSpread({\n        col: col,\n        row: row\n      }, tileType);\n    }\n  }]);\n\n  return Map;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Map);\n\n//# sourceURL=webpack:///./src/avo/map/map.js?");

/***/ }),

/***/ "./src/avo/misc/constants.js":
/*!***********************************!*\
  !*** ./src/avo/misc/constants.js ***!
  \***********************************/
/*! exports provided: SHORT_KEYPRESS_DURATION, MODES, SHAPES, ROTATIONS, DIRECTIONS, ACTION_TYPES, EFFECTS_STACKING, TIME_BETWEEN_SUCCESSIVE_PAYLOADS, EXPECTED_FRAMES_PER_SECOND, EXPECTED_TIMESTEP */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SHORT_KEYPRESS_DURATION\", function() { return SHORT_KEYPRESS_DURATION; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MODES\", function() { return MODES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SHAPES\", function() { return SHAPES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ROTATIONS\", function() { return ROTATIONS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DIRECTIONS\", function() { return DIRECTIONS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ACTION_TYPES\", function() { return ACTION_TYPES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EFFECTS_STACKING\", function() { return EFFECTS_STACKING; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TIME_BETWEEN_SUCCESSIVE_PAYLOADS\", function() { return TIME_BETWEEN_SUCCESSIVE_PAYLOADS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EXPECTED_FRAMES_PER_SECOND\", function() { return EXPECTED_FRAMES_PER_SECOND; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EXPECTED_TIMESTEP\", function() { return EXPECTED_TIMESTEP; });\nvar SHORT_KEYPRESS_DURATION = 1;\nvar MODES = {\n  INITIALISING: 'initialising',\n  ACTION: 'action',\n  INTERACTION: 'interaction'\n};\nvar SHAPES = {\n  NONE: 'none',\n  CIRCLE: 'circle',\n  SQUARE: 'square',\n  POLYGON: 'polygon'\n};\nvar ROTATIONS = {\n  EAST: 0,\n  SOUTHEAST: Math.PI * 0.25,\n  SOUTH: Math.PI * 0.5,\n  SOUTHWEST: Math.PI * 0.75,\n  WEST: Math.PI,\n  NORTHWEST: Math.PI * -0.75,\n  NORTH: Math.PI * -0.5,\n  NORTHEAST: Math.PI * -0.25\n};\nvar DIRECTIONS = {\n  EAST: 0,\n  SOUTH: 1,\n  WEST: 2,\n  NORTH: 3\n};\nvar ACTION_TYPES = {\n  IDLE: 'idle',\n  // Default. Loops.\n  CONTINUOUS: 'continuous',\n  // Requires continuous input (e.g. moving). Loops until cancelled (e.g. user stops pressing arrow keys) or interrupted (e.g. by taking damage and going into the knockback state).\n  STANDARD: 'standard',\n  // Actions that play out all their steps. Cannot be cancelled by new user input. Can be interrupted.\n  SPECIAL_ONCE: 'special once',\n  // Actions that play out all their steps. Cannot be cancelled nor interrupted, except by story scripts.\n  SPECIAL_FOREVER: 'special forever' // Actions that play in a loop. Cannot be cancelled nor interrupted, except by story scripts.\n\n};\n/*\r\nStacking Rules determine what happens when a Particle's Effect payload is\r\napplied to an object that already has the same Effect.\r\n */\n\nvar EFFECTS_STACKING = {\n  STACK: 'stack',\n  // New Effects coexist with old Effects with the same name. \n  NEWEST: 'newest',\n  // Newest Effect overwrites older Effects with the same name.\n  OLDEST: 'oldest' // Old Effects won't be overwritten by new ones with the same name.\n\n};\n/*\r\nWhen it matters (notably with Particles), we prevent collisionScripts from\r\nrunning on every frame. Instead, we provide some breathing space between each\r\n'tick'.\r\n */\n\nvar TIME_BETWEEN_SUCCESSIVE_PAYLOADS = 1000;\n/*\r\nWhile the engine is technically able to support any given framerate (determined\r\nby the hardware), a baseline is required to ground our video game logic to.\r\ne.g. we can say that we expect an object with \"movement speed\" of \"2\" to travel\r\n120 pixels in 1 second. (2 pixels per frame * 60 frames per second)\r\n */\n\nvar EXPECTED_FRAMES_PER_SECOND = 60;\nvar EXPECTED_TIMESTEP = 1000 / EXPECTED_FRAMES_PER_SECOND;\n\n//# sourceURL=webpack:///./src/avo/misc/constants.js?");

/***/ }),

/***/ "./src/avo/misc/image-asset.js":
/*!*************************************!*\
  !*** ./src/avo/misc/image-asset.js ***!
  \*************************************/
/*! exports provided: ImageAsset */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ImageAsset\", function() { return ImageAsset; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ImageAsset = function ImageAsset(url) {\n  _classCallCheck(this, ImageAsset);\n\n  this.url = url;\n  this.img = null;\n  this.loaded = false;\n  this.img = new Image();\n\n  this.img.onload = function () {\n    this.loaded = true;\n  }.bind(this);\n\n  this.img.src = this.url;\n};\n\n//# sourceURL=webpack:///./src/avo/misc/image-asset.js?");

/***/ }),

/***/ "./src/avo/misc/physics.js":
/*!*********************************!*\
  !*** ./src/avo/misc/physics.js ***!
  \*********************************/
/*! exports provided: Physics */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Physics\", function() { return Physics; });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"./src/avo/misc/constants.js\");\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(n); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\nvar USE_CIRCLE_APPROXIMATION = false;\nvar Physics = /*#__PURE__*/function () {\n  function Physics() {\n    _classCallCheck(this, Physics);\n  }\n\n  _createClass(Physics, null, [{\n    key: \"checkCollision\",\n    //----------------------------------------------------------------\n\n    /*  Checks if objA is touching objB.\r\n        If true, returns the corrected coordinates for objA and objB, in form:\r\n          { ax, ay, bx, by }\r\n        If false, returns null.\r\n     */\n    value: function checkCollision(objA, objB) {\n      if (!objA || !objB || objA === objB) return null;\n\n      if (objA.shape === _constants__WEBPACK_IMPORTED_MODULE_0__[\"SHAPES\"].CIRCLE && objB.shape === _constants__WEBPACK_IMPORTED_MODULE_0__[\"SHAPES\"].CIRCLE) {\n        return Physics.checkCollision_circleCircle(objA, objB);\n      } else if ((objA.shape === _constants__WEBPACK_IMPORTED_MODULE_0__[\"SHAPES\"].SQUARE || objA.shape === _constants__WEBPACK_IMPORTED_MODULE_0__[\"SHAPES\"].POLYGON) && (objB.shape === _constants__WEBPACK_IMPORTED_MODULE_0__[\"SHAPES\"].SQUARE || objB.shape === _constants__WEBPACK_IMPORTED_MODULE_0__[\"SHAPES\"].POLYGON)) {\n        return Physics.checkCollision_polygonPolygon(objA, objB);\n      } else if (objA.shape === _constants__WEBPACK_IMPORTED_MODULE_0__[\"SHAPES\"].CIRCLE && (objB.shape === _constants__WEBPACK_IMPORTED_MODULE_0__[\"SHAPES\"].SQUARE || objB.shape === _constants__WEBPACK_IMPORTED_MODULE_0__[\"SHAPES\"].POLYGON)) {\n        if (USE_CIRCLE_APPROXIMATION) return Physics.checkCollision_polygonPolygon(objA, objB);\n        return Physics.checkCollision_circlePolygon(objA, objB);\n      } else if ((objA.shape === _constants__WEBPACK_IMPORTED_MODULE_0__[\"SHAPES\"].SQUARE || objA.shape === _constants__WEBPACK_IMPORTED_MODULE_0__[\"SHAPES\"].POLYGON) && objB.shape === _constants__WEBPACK_IMPORTED_MODULE_0__[\"SHAPES\"].CIRCLE) {\n        if (USE_CIRCLE_APPROXIMATION) return Physics.checkCollision_polygonPolygon(objA, objB);\n        var correction = Physics.checkCollision_circlePolygon(objB, objA);\n\n        if (correction) {\n          correction = {\n            ax: correction.bx,\n            ay: correction.by,\n            bx: correction.ax,\n            by: correction.ay\n          };\n        }\n\n        return correction;\n      }\n\n      return null;\n    } //----------------------------------------------------------------\n\n  }, {\n    key: \"checkCollision_circleCircle\",\n    value: function checkCollision_circleCircle(objA, objB) {\n      var fractionA = 0;\n      var fractionB = 0;\n\n      if (!objA.solid || !objB.solid) {//If either object isn't solid, there's no collision correction.\n      } else if (objA.movable && objB.movable) {\n        fractionA = 0.5;\n        fractionB = 0.5;\n      } else if (objA.movable) {\n        fractionA = 1;\n      } else if (objB.movable) {\n        fractionB = 1;\n      }\n\n      var distX = objB.x - objA.x;\n      var distY = objB.y - objA.y;\n      var dist = Math.sqrt(distX * distX + distY * distY);\n      var minimumDist = objA.radius + objB.radius;\n\n      if (dist < minimumDist) {\n        var angle = Math.atan2(distY, distX);\n        var correctDist = minimumDist;\n        var cosAngle = Math.cos(angle);\n        var sinAngle = Math.sin(angle);\n        return {\n          ax: objA.x - cosAngle * (correctDist - dist) * fractionA,\n          ay: objA.y - sinAngle * (correctDist - dist) * fractionA,\n          bx: objB.x + cosAngle * (correctDist - dist) * fractionB,\n          by: objB.y + sinAngle * (correctDist - dist) * fractionB\n        };\n      }\n\n      return null;\n    } //----------------------------------------------------------------\n\n  }, {\n    key: \"checkCollision_polygonPolygon\",\n    value: function checkCollision_polygonPolygon(objA, objB) {\n      var fractionA = 0;\n      var fractionB = 0;\n\n      if (!objA.solid || !objB.solid) {//If either object isn't solid, there's no collision correction.\n      } else if (objA.movable && objB.movable) {\n        fractionA = 0.5;\n        fractionB = 0.5;\n      } else if (objA.movable) {\n        fractionA = 1;\n      } else if (objB.movable) {\n        fractionB = 1;\n      }\n\n      var correction = null;\n      var verticesA = objA.vertices;\n      var verticesB = objB.vertices;\n      var projectionAxes = [].concat(_toConsumableArray(Physics.getShapeNormals(objA)), _toConsumableArray(Physics.getShapeNormals(objB)));\n\n      for (var i = 0; i < projectionAxes.length; i++) {\n        var axis = projectionAxes[i];\n        var projectionA = {\n          min: Infinity,\n          max: -Infinity\n        };\n        var projectionB = {\n          min: Infinity,\n          max: -Infinity\n        };\n\n        for (var j = 0; j < verticesA.length; j++) {\n          var val = Physics.dotProduct(axis, verticesA[j]);\n          projectionA.min = Math.min(projectionA.min, val);\n          projectionA.max = Math.max(projectionA.max, val);\n        }\n\n        for (var _j = 0; _j < verticesB.length; _j++) {\n          var _val = Physics.dotProduct(axis, verticesB[_j]);\n\n          projectionB.min = Math.min(projectionB.min, _val);\n          projectionB.max = Math.max(projectionB.max, _val);\n        }\n\n        var overlap = Math.max(0, Math.min(projectionA.max, projectionB.max) - Math.max(projectionA.min, projectionB.min));\n\n        if (!correction || overlap < correction.magnitude) {\n          var sign = Math.sign(projectionB.min + projectionB.max - (projectionA.min + projectionA.max));\n          correction = {\n            magnitude: overlap,\n            x: axis.x * overlap * sign,\n            y: axis.y * overlap * sign\n          };\n        }\n      }\n\n      if (correction && correction.magnitude > 0) {\n        return {\n          ax: objA.x - correction.x * fractionA,\n          ay: objA.y - correction.y * fractionA,\n          bx: objB.x + correction.x * fractionB,\n          by: objB.y + correction.y * fractionB\n        };\n      }\n\n      return null;\n    } //----------------------------------------------------------------\n\n  }, {\n    key: \"checkCollision_circlePolygon\",\n    value: function checkCollision_circlePolygon(objA, objB) {\n      var fractionA = 0;\n      var fractionB = 0;\n\n      if (!objA.solid || !objB.solid) {//If either object isn't solid, there's no collision correction.\n      } else if (objA.movable && objB.movable) {\n        fractionA = 0.5;\n        fractionB = 0.5;\n      } else if (objA.movable) {\n        fractionA = 1;\n      } else if (objB.movable) {\n        fractionB = 1;\n      }\n\n      var distX = objB.x - objA.x;\n      var distY = objB.y - objA.y;\n      var dist = Math.sqrt(distX * distX + distY * distY);\n      var angle = Math.atan2(distY, distX);\n      var centreToCentreAxis = dist !== 0 ? {\n        x: distX / dist,\n        y: distY / dist\n      } : {\n        x: 0,\n        y: 0\n      };\n      var correction = null;\n      var verticesB = objB.vertices;\n      var projectionAxes = [centreToCentreAxis].concat(_toConsumableArray(Physics.getShapeNormals(objB)));\n\n      for (var i = 0; i < projectionAxes.length; i++) {\n        var axis = projectionAxes[i];\n        var scalarA = Physics.dotProduct(axis, {\n          x: objA.x,\n          y: objA.y\n        });\n        var projectionA = {\n          min: scalarA - objA.radius,\n          max: scalarA + objA.radius\n        };\n        var projectionB = {\n          min: Infinity,\n          max: -Infinity\n        };\n\n        for (var j = 0; j < verticesB.length; j++) {\n          var val = Physics.dotProduct(axis, verticesB[j]);\n          projectionB.min = Math.min(projectionB.min, val);\n          projectionB.max = Math.max(projectionB.max, val);\n        }\n\n        var overlap = Math.max(0, Math.min(projectionA.max, projectionB.max) - Math.max(projectionA.min, projectionB.min));\n\n        if (!correction || overlap < correction.magnitude) {\n          var sign = Math.sign(projectionB.min + projectionB.max - (projectionA.min + projectionA.max));\n          correction = {\n            magnitude: overlap,\n            x: axis.x * overlap * sign,\n            y: axis.y * overlap * sign\n          };\n        }\n      }\n\n      if (correction && correction.magnitude > 0) {\n        return {\n          ax: objA.x - correction.x * fractionA,\n          ay: objA.y - correction.y * fractionA,\n          bx: objB.x + correction.x * fractionB,\n          by: objB.y + correction.y * fractionB\n        };\n      }\n    } //----------------------------------------------------------------\n\n    /*  Gets the NORMALISED normals for each edge of the object's shape. Assumes the object has the 'vertices' property.\r\n     */\n\n  }, {\n    key: \"getShapeNormals\",\n    value: function getShapeNormals(obj) {\n      var vertices = obj.vertices;\n      if (!vertices) return null;\n      if (vertices.length < 2) return []; //Look you need to have at least three vertices to be a shape.\n      //First, calculate the edges connecting each vertice.\n      //--------------------------------\n\n      var edges = [];\n\n      for (var i = 0; i < vertices.length; i++) {\n        var p1 = vertices[i];\n        var p2 = vertices[(i + 1) % vertices.length];\n        edges.push({\n          x: p2.x - p1.x,\n          y: p2.y - p1.y\n        });\n      } //--------------------------------\n      //Calculate the NORMALISED normals for each edge.\n      //--------------------------------\n\n\n      return edges.map(function (edge) {\n        var dist = Math.sqrt(edge.x * edge.x + edge.y * edge.y);\n        if (dist === 0) return {\n          x: 0,\n          y: 0\n        };\n        return {\n          x: -edge.y / dist,\n          y: edge.x / dist\n        };\n      }); //--------------------------------\n    } //----------------------------------------------------------------\n\n  }, {\n    key: \"dotProduct\",\n    value: function dotProduct(vectorA, vectorB) {\n      if (!vectorA || !vectorB) return null;\n      return vectorA.x * vectorB.x + vectorA.y * vectorB.y;\n    } //----------------------------------------------------------------\n\n  }]);\n\n  return Physics;\n}();\n\n//# sourceURL=webpack:///./src/avo/misc/physics.js?");

/***/ }),

/***/ "./src/avo/reactions/index.js":
/*!************************************!*\
  !*** ./src/avo/reactions/index.js ***!
  \************************************/
/*! exports provided: STANDARD_REACTIONS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"STANDARD_REACTIONS\", function() { return STANDARD_REACTIONS; });\nvar STANDARD_REACTIONS = {\n  DAMAGE: {\n    onAdd: function onAdd(_ref) {\n      var app = _ref.app,\n          entity = _ref.entity,\n          effect = _ref.effect;\n    },\n    always: function always(_ref2) {\n      var app = _ref2.app,\n          entity = _ref2.entity,\n          effect = _ref2.effect;\n    },\n    onRemove: function onRemove(_ref3) {\n      var app = _ref3.app,\n          entity = _ref3.entity,\n          effect = _ref3.effect;\n    }\n  },\n  PUSH: {\n    onAdd: function onAdd(_ref4) {\n      var app = _ref4.app,\n          entity = _ref4.entity,\n          effect = _ref4.effect;\n      console.log('NEW PUSH!');\n    },\n    always: function always(_ref5) {\n      var app = _ref5.app,\n          entity = _ref5.entity,\n          effect = _ref5.effect,\n          timeStep = _ref5.timeStep;\n      var power = effect.attr && effect.attr.power || 0;\n      var angle = effect.attr && effect.attr.angle || 0;\n      entity.pushX += power * timeStep / 1000 * Math.cos(angle);\n      entity.pushY += power * timeStep / 1000 * Math.sin(angle);\n\n      if (effect.attr.decay && effect.attr.power) {\n        effect.attr.power = Math.max(effect.attr.power - effect.attr.decay * timeStep / 1000, 0);\n      }\n    },\n    onRemove: function onRemove(_ref6) {\n      var app = _ref6.app,\n          entity = _ref6.entity,\n          effect = _ref6.effect;\n      console.log('PUSH FINISHED!');\n    }\n  }\n};\n\n//# sourceURL=webpack:///./src/avo/reactions/index.js?");

/***/ }),

/***/ "./src/avo/story.js":
/*!**************************!*\
  !*** ./src/avo/story.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/misc/constants */ \"./src/avo/misc/constants.js\");\n/* harmony import */ var _avo_misc_image_asset__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/misc/image-asset */ \"./src/avo/misc/image-asset.js\");\n/* harmony import */ var _avo_entities_actor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @avo/entities/actor */ \"./src/avo/entities/actor.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\nvar Story = /*#__PURE__*/function () {\n  function Story(app) {\n    _classCallCheck(this, Story);\n\n    this._app = app; // Assets\n\n    app.assets.basicActor = new _avo_misc_image_asset__WEBPACK_IMPORTED_MODULE_1__[\"ImageAsset\"]('assets/actor-v2.png');\n    app.playerActor = new _avo_entities_actor__WEBPACK_IMPORTED_MODULE_2__[\"default\"](app, {\n      x: 32 * 8,\n      y: 32 * 2.5,\n      size: 32,\n      animationSpritesheet: app.assets.basicActor\n    });\n    app.actors.push(app.playerActor);\n    var testActorA = new _avo_entities_actor__WEBPACK_IMPORTED_MODULE_2__[\"default\"](app, {\n      x: 32 * 6.5,\n      y: 32 * 2.5,\n      size: 32,\n      animationSpritesheet: app.assets.basicActor\n    });\n    app.actors.push(testActorA); // Set camera to follow player actor\n\n    app.camera.targetActor = app.playerActor; // TODO:\n    // app.addActor();\n    // app.addAsset();\n  }\n\n  _createClass(Story, [{\n    key: \"start\",\n    value: function start() {\n      var app = this._app;\n      console.info('STORY IS READY TO START!');\n      app.changeMode(_avo_misc_constants__WEBPACK_IMPORTED_MODULE_0__[\"MODES\"].ACTION);\n    }\n  }, {\n    key: \"skipPlay\",\n    value: function skipPlay() {\n      return false;\n    }\n  }, {\n    key: \"customPlay\",\n    value: function customPlay(timeStep) {}\n  }, {\n    key: \"skipPaint\",\n    value: function skipPaint() {\n      return false;\n    }\n  }, {\n    key: \"customPaint\",\n    value: function customPaint() {}\n  }]);\n\n  return Story;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Story);\n\n//# sourceURL=webpack:///./src/avo/story.js?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _avo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./avo */ \"./src/avo/index.js\");\n\n\nwindow.onload = function () {\n  window.app = new _avo__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n};\n\n//# sourceURL=webpack:///./src/main.js?");

/***/ })

/******/ });